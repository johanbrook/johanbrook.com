<p>At <a href="https://lookback.io">Lookback</a>, we've fallen in love with functional reactive programming with streams in our frontend apps. Together with the use of Typescript for compile time type safety, we've seen a tremendous bump in overall stability and fewer runtime bugs. Actually, I dare to say that <em>all</em> of our bugs so far have been either logic (programmer) or timing errors.</p>
<p>That's why we've extracted the patterns we've been using in our frontend apps to a library we call <strong>Frap</strong> (&quot;<strong>F</strong>unctional <strong>R</strong>eactive <strong>Ap</strong>p&quot;). You can find it here:</p>
<p class="tc">
  <a href="https://github.com/lookback/frap" class="btn">‚ú® lookback/frap on GitHub</a>
</p>
<ul>
<li>üî® ~20 Kb minified.</li>
<li>üìâ Has a single dependency (the <code>xstream</code> library).</li>
<li>üèÑ‚Äç‚ôÇÔ∏è The core API consists of two functions.</li>
<li>ü§ù Agnostic about the view, but assumes a stream based application.</li>
</ul>
<h2>What this text is and what it's not</h2>
<p>We'll look at how <em>easy</em> it actually is to build these kind of frontend architectures on your own. Frap is, to be clear, <em>not</em> any new or novel idea at all. As you will read below, it's essentially a rip off of a library called CycleJS, but less general and made to work with React as a view before CycleJS had proper React support.</p>
<p>What we'll go through is how one can reason about state, side effects, and drawing the view with the data structure streams. In the end, we have the complete library.</p>
<p><strong>‚ö†Ô∏è I'll assume knowledge about streams in this post.</strong> The xstream library will be used for reactive streams, but the concepts are applicable to any streams implementation with the basic operations. I will also use Typescript features to model the architecture of Frap.</p>
<h2>Why?</h2>
<p>For me personally, it was all about the <em>joy</em> of constructing an architecture I could understand the smallest parts of, and then extracting it to make it general.</p>
<p>It felt good not using a 3rd party package (except for <code>xstream</code>‚Ä¶) to solve a thing.</p>
<h2>Credits</h2>
<p>The main brain behind the architecture is my colleague <a href="https://twitter.com/algstn">Martin</a>. He was the drive behind the functional patterns as we pair programmed to build the architecture for Lookback's Live player. The extraction and polishing was made by myself.</p>
<h2>Background</h2>
<p>We do make use of <a href="https://cycle.js.org">CycleJS</a> in one of our web clients. CycleJS introduced the concept of cyclical streams and <em>drivers</em> for side effects for us. Go ahead and read about all its features on the website. It was a bit daunting for me in the beginning to &quot;think in cyclical streams&quot;, but a few months in I'm happier than ever building a single page client app.</p>
<p>I recommend reading these texts on streams and reactive programming:</p>
<ul>
<li><a href="https://cycle.js.org/streams.html">&quot;Streams&quot; on CycleJS.org</a></li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">&quot;The introduction to Reactive Programming you've been missing&quot;</a> by Andr√© Staltz, creator of xstream and CycleJS.</li>
<li><a href="https://futureofcoding.org/papers/comprehensible-frp/comprehensible-frp.pdf">&quot;Explicitly Comprehensible Functional Reactive Programming (pdf)&quot;</a></li>
</ul>
<p>Have a look at the CycleJS documentation and guides. Then let's see why we decided to <em>not</em> go with CycleJS for a new single page app.</p>
<h3>Differences in drawing a DOM</h3>
<p>Out-of-the-box, CycleJS uses <a href="https://github.com/snabbdom/snabbdom">Snabbdom</a> ‚Äì a virtual DOM library ‚Äì to build your app's HTML and insert into the browser. CycleJS supports <a href="https://cycle.js.org/components.html">components</a>, i.e. reusable functions that emit a DOM and take props.</p>
<p>A component in CycleJS/Snabbdom might look like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> xs <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> div<span class="token punctuation">,</span> span<span class="token punctuation">,</span> input <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@cycle/dom'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter">sources</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token comment">// Incoming DOM from the outside:</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> domSource <span class="token operator">=</span> sources<span class="token punctuation">.</span><span class="token constant">DOM</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Stream of new text values from our &lt;input> element</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> newValue$ <span class="token operator">=</span> domSource</span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">'.input'</span><span class="token punctuation">)</span> <span class="token comment">// The &lt;input> has class="input"</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">events</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span> <span class="token comment">// Listen to `input` events</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token operator">=></span> ev<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// For each input, grab the `value`</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Build a stream of state, which looks like:</span></span><br><span class="highlight-line">  <span class="token comment">//  Stream&lt;{ value: string }></span></span><br><span class="highlight-line">  <span class="token keyword">const</span> state$ <span class="token operator">=</span> newValue$<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remember</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Remember last value</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Render out the UI from our state using Snabbdom. This is</span></span><br><span class="highlight-line">  <span class="token comment">// a virtual DOM implementation, and we build the structure</span></span><br><span class="highlight-line">  <span class="token comment">// using Hyperscript.</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> vdom$ <span class="token operator">=</span> state$<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span></span><br><span class="highlight-line">    <span class="token function">div</span><span class="token punctuation">(</span><span class="token punctuation">[</span></span><br><span class="highlight-line">      <span class="token function">span</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">      <span class="token function">input</span><span class="token punctuation">(</span><span class="token string">'.input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">        attrs<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">type</span><span class="token punctuation">:</span> <span class="token string">'text'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span><br><span class="highlight-line">      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token punctuation">]</span><span class="token punctuation">)</span></span><br><span class="highlight-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Finally, return our DOM to the outside, along with the</span></span><br><span class="highlight-line">  <span class="token comment">// values from our &lt;input></span></span><br><span class="highlight-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token constant">DOM</span><span class="token punctuation">:</span> vdom$<span class="token punctuation">,</span></span><br><span class="highlight-line">    value<span class="token punctuation">:</span> state$<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> state<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span></code></pre>
<p>The DOM flows through the component as a <em>stream</em>. Compare this with a React component where you return the virtual DOM as a lump of JSX:</p>
<pre class="language-tsx"><code class="language-tsx"><span class="highlight-line"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>text<span class="token punctuation">,</span> setText<span class="token punctuation">]</span> <span class="token operator">=</span> useState<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span><span class="token plain-text">('');<br><span class="highlight-line"></span><br><span class="highlight-line">  return (</span><br><span class="highlight-line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span><br><span class="highlight-line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text"></span><br><span class="highlight-line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span></span><br><span class="highlight-line">        <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span></span><br><span class="highlight-line">        <span class="token attr-name">defaultValue</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>text<span class="token punctuation">}</span></span></span><br><span class="highlight-line">        <span class="token attr-name">onInput</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setText</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span></span><br><span class="highlight-line">      <span class="token punctuation">/></span></span><span class="token plain-text"></span><br><span class="highlight-line">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"></span><br><span class="highlight-line">  );</span><br><span class="highlight-line">}</span></span></code></pre>
<p>The React component <em>probably</em> looks more straight forward to most people than the CycleJS component, I imagine. It's because it's <em>imperative</em>. We use <code>setText</code> and perhaps <code>this.setState</code> in React components ‚Äì a concept that doesn't exist in CycleJS's world. In CycleJS, something needs to &quot;pull&quot; the values through the streams through the component. Streams are, aptly, flowing through the whole app.</p>
<h3>Building our own</h3>
<p>I think the Snabbdom way of building markup is interesting. It encourages me to think about my frontend code as functions even more (JSX sort of hides that away). For a rewrite of our Live player, we decided we wanted to use React for the view, instead of doing full CycleJS/Snabbdom again. This was before <a href="https://github.com/cyclejs/react">@cycle/react</a> was released, so we set out to fully ditch CycleJS for this rewrite and figure out how to make business logic in streams play well with React for the view.</p>
<p>The choice of React for the view was partly due to some odd quirks in how CycleJS handles DOM events, and partly due to the nice React ecosystem. Typescript and React go perfect together too, making for robust view components.</p>
<p>In our new architecture, we wanted to keep these concepts from CycleJS:</p>
<ul>
<li>All business logic as reactive streams.</li>
<li>Handling side effects in Drivers, making for a &quot;pure&quot; main application.</li>
</ul>
<p>These things we wanted to get rid of:</p>
<ul>
<li>Replace the DOM-as-a-stream and Snabbdom rendering with React.</li>
</ul>
<p>We also wanted to include these ideas:</p>
<ul>
<li>Storing the whole app state as a central atom and draw the whole user interface based on that.</li>
</ul>
<p>Let's begin!</p>
<h2>State &amp; data flow</h2>
<p>How to manage state in frontend applications has turned out to be a hot topic. What is app state anyway? It might be:</p>
<ul>
<li>An ID string of the currently signed in user.</li>
<li>An array of blog posts.</li>
<li>A boolean indicating if a modal is open or not.</li>
<li>An enum for the current state in a state machine.</li>
</ul>
<p>And so on. The basic idea is that we should be able to <strong>draw the whole interface from this state</strong>. Sometimes, using local state in components is fine. This might be state such as the active tab in a tab system, which is very local, and <em>probably</em> doesn't concern any other parts of the system.</p>
<p>Redux popularized the Flux architecture's idea of state as &quot;single source of truth&quot;. We shouldn't scatter the state across DOM nodes, localStorage, the server, and so on. Also Elm and Om are great inspiration for state handling in client side apps. I encourage you to read the <a href="https://redux.js.org/introduction/motivation">philosophies and principles of Redux</a>.</p>
<p>A state atom might look like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">const</span> state<span class="token punctuation">:</span> State <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token string">'Johan Brook'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  showModal<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>From this, we should be able to draw the full app component tree. And if we'd draw it again from the same state, the app's UI can't change fundamentally.</p>
<hr>
<p>A core principle of functional programming is immutability ‚Äì the inability to change a state after it's created. We'd like our app state to work the same. Meaning, we can't just &quot;set a property in the state&quot; like it's the Wild West.¬†We need to update properties incrementally and generate a &quot;new&quot; state. For each of these state updates, the view should re-draw. &quot;Re-draw on each state update?! Isn't that crazy expensive for the view?&quot;. Not if we trust the virtual DOM algorithms out there!</p>
<p>In order to update the <code>name</code> in our state, we can design the flow like this:</p>
<ol>
<li>Construct your update to the state atom. In this case <code>{ name: 'John Doe' }</code>.</li>
<li>Send the update as a stream to a function which folds it together with the state stream:</li>
</ol>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">const</span> state$ <span class="token operator">=</span> stateUpdate$<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span></span><br><span class="highlight-line">  <span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> update</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>update <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  startState</span><br><span class="highlight-line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<p>The update effectively extends the existing state object to form a new one.</p>
<p>So we've got a <code>state$</code> variable containing the <em>stream of states</em>. The idea is to let the view listen to this <code>state$</code> stream, which will behave like this:</p>
<pre><code>----------------- update: { name: 'Johnny Doe' }----
  stateUpdate$.fold(..., startState)
{ name: 'Johan Brook' }--{ name: 'Johnny Doe' }----- = state$
</code></pre>
<p>For each new element in the resulting <code>state$</code> stream, we'll re-render the whole app (read more below about how we'll manage the view).</p>
<p>So what are these state updates? It's ‚ú®<strong>your application</strong> ‚ú®! That's right: all business logic will either result in state updates or side effects (read more about that in the section about Drivers below).</p>
<p>This can be expressed roughly like this (with xstream):</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> Stream <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  showModal<span class="token punctuation">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Our app just returns a new `name` instantly, but here</span></span><br><span class="highlight-line"><span class="token comment">// we would render our entire app as React components or similar.</span></span><br><span class="highlight-line"><span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">return</span> state$<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><span class="highlight-line">    name<span class="token punctuation">:</span> <span class="token string">'Mary'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> <span class="token function-variable function">run</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">main<span class="token punctuation">:</span> Main<span class="token punctuation">,</span> startState<span class="token punctuation">:</span> State</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token comment">// Create an incrementally updated stream of state</span></span><br><span class="highlight-line">  <span class="token comment">// XXX Fix stateUpdate$</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> state$ <span class="token operator">=</span> stateUpdate$<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span></span><br><span class="highlight-line">    <span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> update</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>update <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    startState</span><br><span class="highlight-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Main app function, renders UI from state$ stream</span></span><br><span class="highlight-line">  <span class="token function">main</span><span class="token punctuation">(</span>state$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Kick off! üöÄ</span></span><br><span class="highlight-line"><span class="token function">run</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Johan'</span><span class="token punctuation">,</span> showModal<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<p>Sharp eyed readers notice that <code>stateUpdate$</code> is appearing out of nowhere. That's supposed to come from the app function, right?! Here's what the &quot;cyclical&quot; in CycleJS comes in: we need to cycle back the state updates from our app up to the <code>fold</code> operation. Luckily, the xstream library has an <a href="http://staltz.github.io/xstream/#imitate"><code>imitate</code></a> method on a stream which makes it possible to create a fake stream at the top of a function, run operations on it, and then let it imitate a &quot;real&quot; stream further down the file. This allows circular dependency of streams.</p>
<p>Let's fix our code:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> xs <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> <span class="token function-variable function">run</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">main<span class="token punctuation">:</span> Main<span class="token punctuation">,</span> startState<span class="token punctuation">:</span> State</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token comment">// Create "fake", empty update stream</span></span><br><ins class="highlight-line highlight-line-add">  <span class="token keyword">const</span> fakeUpdates$ <span class="token operator">=</span> xs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></ins><br><ins class="highlight-line highlight-line-add"></ins><br><span class="highlight-line">  <span class="token keyword">const</span> state$ <span class="token operator">=</span> stateUpdate$<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span></span><br><span class="highlight-line">    <span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> update</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>update <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    startState</span><br><span class="highlight-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><ins class="highlight-line highlight-line-add"></ins><br><span class="highlight-line">  <span class="token keyword">const</span> appUpdate$ <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span>state$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><ins class="highlight-line highlight-line-add"></ins><br><ins class="highlight-line highlight-line-add">  <span class="token comment">// Imitate the real state update stream - results are</span></ins><br><ins class="highlight-line highlight-line-add">  <span class="token comment">// cycled back to the .fold operation above!</span></ins><br><span class="highlight-line">  fakeUpdates$<span class="token punctuation">.</span><span class="token function">imitate</span><span class="token punctuation">(</span>appUpdate$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">return</span> state$<span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#create">Docs on <code>xs.create</code></a></p>
<p>We've successfully achieved feeding our app with a stream of state, and made the output stream of the app update the state! üéâ This creates a <code>main</code> function signature of:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">type</span> <span class="token function-variable function">Main</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> Stream<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>State<span class="token operator">>></span><span class="token punctuation">;</span></span></code></pre>
<p><strong>This <code>run</code> function is included in Frap for you.</strong> Thus, state management is ticked off for you. You just need to provide the <code>main</code> function which is your whole app logic.</p>
<p>Takeaways:</p>
<ul>
<li>We update our state with updates via a stream.</li>
<li>Our main app function <em>takes a state stream</em> and <em>returns an update stream</em>.</li>
<li>The state is thus incrementally updated.</li>
<li>The view is re-rendered each time the state updates.</li>
</ul>
<h2>Ch..ch..changes ‚Ä¶ (to the state)</h2>
<p>Let's explore the <code>run</code> function from the earlier example (remember that <code>run</code> is exported by Frap, so it's not code you'd write yourself in your app).</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token comment">// run :: (Main, State) -> Stream&lt;State></span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> run <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'frap'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> startState<span class="token punctuation">:</span> State <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token string">'Johan'</span><span class="token punctuation">,</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Our app's business logic, packaged in a single function.</span></span><br><span class="highlight-line"><span class="token comment">// Receives state stream and should return a stream of updates</span></span><br><span class="highlight-line"><span class="token comment">// to the state.</span></span><br><span class="highlight-line"><span class="token comment">// app :: (Stream&lt;State>) -> Stream&lt;Partial&lt;State>></span></span><br><span class="highlight-line"><span class="token keyword">const</span> app<span class="token punctuation">:</span> <span class="token function-variable function">Main</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> stateUpdate$ <span class="token operator">=</span> xs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">return</span> stateUpdate$<span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Kick it off! üöÄ</span></span><br><span class="highlight-line"><span class="token function">run</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> startState<span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<p>That <code>app</code> function is basically everything there is to it! (almost‚Ä¶ we just need to sort out the view rendering and handle side effects). We receive state, do stuff deriving off of it, and return our preferred updates.</p>
<p>An example could be:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">const</span> app<span class="token punctuation">:</span> <span class="token function-variable function">Main</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> stateUpdate$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>State<span class="token operator">>></span> <span class="token operator">=</span> state$<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><ins class="highlight-line highlight-line-add">    name<span class="token punctuation">:</span> state<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></ins><br><ins class="highlight-line highlight-line-add">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></ins><br><ins class="highlight-line highlight-line-add"></ins><br><ins class="highlight-line highlight-line-add">  <span class="token keyword">return</span> stateUpdate$<span class="token punctuation">;</span></ins><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#map">Docs on <code>map</code></a></p>
<p>This little app of ours would instantly update the <code>name</code> property in our state atom to uppercase:</p>
<pre><code>--- { name: 'Johan' } ---
  app()
--- { name: 'JOHAN' } ---
</code></pre>
<p>Now, this seems silly and simplistic. I thought so too. &quot;How can I ever achieve complex app logic with this?!&quot;. Turns out you can. By using the stream operators of xstream on your data, you really <em>can</em> achieve crazy things. It all adds up. For me, it was all about separating the big state down into small functions taking care of &quot;their&quot; domain, and then merging it all together:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token comment">// Functions we've written to take care of stuff in our data model.</span></span><br><span class="highlight-line"><span class="token comment">// We don't care how they do it ‚Äì as long as their return a stream</span></span><br><span class="highlight-line"><span class="token comment">// of state updates.</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> nameUpdate<span class="token punctuation">,</span> posts <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> app<span class="token punctuation">:</span> <span class="token function-variable function">Main</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> nameUpdate$ <span class="token operator">=</span> <span class="token function">nameUpdate</span><span class="token punctuation">(</span>state$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> postsUpdate$ <span class="token operator">=</span> <span class="token function">posts</span><span class="token punctuation">(</span>state$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// All derived state updates off of existing state</span></span><br><span class="highlight-line">  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>nameUpdate$<span class="token punctuation">,</span> postsUpdate$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#merge">Docs on <code>xs.merge</code></a></p>
<p>One important aspect here is the <em>cyclical</em> aspect of our app architecture. Notice how the state stream is constantly giving us new state as elements in the stream. Our <code>app</code> function is merely a transformer along the way, returning state updates as sinks and receives the new state as source:</p>
<pre><code>------a---ax---ax------
  app() # Transforms the source stream
------ax--ax---axy-----
</code></pre>
<p>Once you're used to &quot;thinking in cycles&quot;, it creates quite a nice way of programming even complex apps, since the pattern is very scalable. You'll be thinking in &quot;inputs and outputs&quot;, and solely how you will transform the inputs to a given output.</p>
<p>But derived state ain't no fun. In a real app, we've got lots of inputs! Mouse clicks from the user, async calls coming back from web APIs ‚Äì a myriad of things that should update our state. Let's investigate the former!</p>
<h2>Sending -&gt; Messages</h2>
<p>Any app must deal with user input. Button clicks, text fields, forms, and so on. As our app architecture looks so far, there's only derived state updates. Meaning, we only transform the state we have already.</p>
<p><strong>We need to construct a way to let the view pass messages to our app function.</strong></p>
<p>We haven't looked at the view yet, but remember it's <strong>outside</strong> our pure, cozy, functional world inside of our app function. In the app function, we solely deal with functional streams which we apply <code>map</code>, <code>filter</code> and other operations on.</p>
<p>When I say <em>messages</em>, I refer to something like <em>signals</em> or <em>events</em> that are emitted from the UI element the user interacted with. We need two things in these messages:</p>
<ol>
<li>An identifier in order to distinguish between different kinds of messages.</li>
<li>An optional payload with data attached to the message.</li>
</ol>
<p>Let's see how we can get those messages into our app function!</p>
<p>We've modelled data as streams so far, so why not continue on that track. Imagine a <code>view$</code> stream which is a stream of <em>all</em> different kinds of messages ‚Äì user input ‚Äì coming from the view.</p>
<p>I imagine this flow being something like this:</p>
<figure id="view-model">
  <img width="413" alt="Messages flow" src="/assets/posts/frap-messages.png">
  <figcaption>Simplified flow diagram.</figcaption>
</figure>
<p>How does a message look like then? Perhaps like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">ToggleModal</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  kind<span class="token punctuation">:</span> <span class="token string">'toggle_modal'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  modalName<span class="token punctuation">:</span> <span class="token string">'surveyModal'</span> <span class="token operator">|</span> <span class="token string">'loginModal'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  open<span class="token punctuation">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">SetPerson</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  kind<span class="token punctuation">:</span> <span class="token string">'set_person'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  person<span class="token punctuation">:</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line">    age<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">type</span> View <span class="token operator">=</span> ToggleModal <span class="token operator">|</span> SetPerson<span class="token punctuation">;</span></span></code></pre>
<p>The last <code>View</code> type forms the union type which our messages stream consists of: <code>Stream&lt;View&gt;</code>. Let's investigate how this fits into our app architecture.</p>
<p>We've got our <code>app</code> function which produces state updates and receives state from <code>run</code>. The latter can be modified to accept a stream of view messages:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> xs <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> run <span class="token operator">=</span> <span class="token operator">&lt;</span>View<span class="token operator">></span><span class="token punctuation">(</span><span class="token parameter">main<span class="token punctuation">:</span> Main<span class="token punctuation">,</span> view$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>View<span class="token operator">></span><span class="token punctuation">,</span> startState<span class="token punctuation">:</span> State</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> fakeUpdates$ <span class="token operator">=</span> xs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> state$ <span class="token operator">=</span> stateUpdate$<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span></span><br><span class="highlight-line">    <span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> update</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>update <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    startState</span><br><span class="highlight-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> appUpdate$ <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span>state$<span class="token punctuation">,</span> view$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  fakeUpdates$<span class="token punctuation">.</span><span class="token function">imitate</span><span class="token punctuation">(</span>appUpdate$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">return</span> state$<span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>I've introduced a generic type <code>View</code> in the <code>run</code> function. Let's start our app:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token comment">// run :: (Main, Stream&lt;V>, State) -> Stream&lt;State></span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> run <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'frap'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">const</span> startState<span class="token punctuation">:</span> State <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token string">'Johan'</span><span class="token punctuation">,</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">SetName</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  kind<span class="token punctuation">:</span> <span class="token string">'set_name'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">type</span> View <span class="token operator">=</span> SetName<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> app<span class="token punctuation">:</span> <span class="token function-variable function">Main</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span><span class="token punctuation">,</span> view$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>View<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> stateUpdate$ <span class="token operator">=</span> view$</span><br><span class="highlight-line">    <span class="token comment">// Only filter on the `SetName` type of messages</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span> m <span class="token keyword">is</span> <span class="token parameter">SetName</span> <span class="token operator">=></span> <span class="token operator">!</span><span class="token operator">!</span>m<span class="token punctuation">.</span>kind <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">'set_name'</span><span class="token punctuation">)</span></span><br><span class="highlight-line">    <span class="token comment">// Set a new name by mapping the payload from the message to a state update</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><span class="highlight-line">      name<span class="token punctuation">:</span> m<span class="token punctuation">.</span>name<span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">return</span> xs<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>stateUpdate$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// TODO Build view and construct messages stream</span></span><br><span class="highlight-line"><span class="token keyword">const</span> view$ <span class="token operator">=</span> xs<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>View<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Kick it off! üöÄ</span></span><br><span class="highlight-line"><span class="token function">run</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> view$<span class="token punctuation">,</span> startState<span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<p>Now, <em>imagine</em> that the <code>view$</code> stream is working. Imagine that for every time a user is submitting a form text field with some text, the view will construct the <code>SetName</code> message object and put it on the view stream. This view stream can flow through our app's business logic as a regular function parameter, and we can <code>filter</code> to get specific messages and then <code>map</code> them to do state updates.</p>
<p>This makes the separation between view and business logic pretty clear ‚Äì which is a good thing! We can test our app in isolation by feeding mocked messages into the view stream and asserting the resulting state without having to mount the view. The view's actions don't have to be side effects, as it's often regarded to be in other app setups.</p>
<hr>
<p>So far, we've stayed inside or pure, functional domain of streams. The next section will go through the elephant in the room.</p>
<h2>A View to a <s>kill</s> Stream</h2>
<p>We begin with this simple but beautiful idea:</p>
<blockquote>
<p>ui = view(state)</p>
</blockquote>
<p><em>The View is a function of state, producing User Interface.</em></p>
<p>This idea isn't new of course: it exists in various shapes and philosophies, such as MVC, MVVM, MVI, and so on. The concept of having a view that listens to state is a baseline in many design patterns.</p>
<p><strong>Q:</strong> But how do we do this in Frap? Where we have a single stream of state?</p>
<p><strong>A:</strong> We rely on a virtual DOM!</p>
<p>This means, we re-render our whole component tree on each new state update. This feels terribly expensive and weird, but we must simply rely on that our virtual DOM implementation will calculate the smallest diff in the real DOM and apply that. The whole design idea behind React is built on this principle: to rely on the virtual DOM.</p>
<p>As you saw above in the code samples at the top, UI components in CycleJS use streams as first class citizens. The components are really just functions which accepts input streams and return output streams. A common lingo in the streams world is <em>Sources</em> and <em>Sinks</em> to signify the input and outputs. Thanks to this property of CycleJS, components can receive a stream of values (&quot;props&quot; in React world) and return a stream of virtual DOM nodes and a stream of new values, emitted from the component. React works differently. React components <em>must</em> return JSX (or a virtual DOM node, however you choose to write it). So we just can't make React components return a stream of JSX and expect things to work, of course.</p>
<p>Have a look at the <a href="#view-model">view figure</a> again. We see that the view should accept a state stream and &quot;return&quot; a messages stream (I say &quot;return&quot; within quotes since it's not really gonna return the stream).</p>
<p>But how do we draw a whole React app from a stream? We can't return a stream of virtual DOM nodes here?</p>
<p><strong>We must open up the state stream somehow and let it drive the rendering of the top level component.</strong></p>
<p>(This means the React app will re-render on each state update. <em>Again, this is fine</em>. Does the app feel slow? Profile with React's dev tools, as <a href="https://twitter.com/ryanflorence/status/1126734015950536706">this tweet</a> advises).</p>
<p>In most stream libraries, there's a method called <code>subscribe</code> which you can use on a stream. In xstream, it adds a listener on a stream and returns a subscription that can be used to remove that listener (read the <a href="http://staltz.github.io/xstream/#subscribe">docs</a>). We can use that to subscribe to state updates, and then unsubscribe when our app unmounts.</p>
<p>In the <code>next</code> callback of <code>subscribe</code>, we'll receive each new element in the stream (we can also catch errors in <code>error</code>). We use <code>next</code> to set the state of the React component at top level. From then on, we'll let React figure out how to draw the DOM based on that very state. For each new state update, <code>next</code> will be called, and React will re-render the tree. Incremental, immutable state.</p>
<p>Here's the function signature of <code>run</code>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">type</span> <span class="token function-variable function">Run</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Main<span class="token punctuation">,</span> view$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>View<span class="token operator">></span><span class="token punctuation">,</span> startState<span class="token punctuation">:</span> State</span><span class="token punctuation">)</span> <span class="token operator">=></span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span><span class="token punctuation">;</span></span></code></pre>
<p>Before, we've just called <code>run</code> for funsies without really thinking too much about where and how we'll handle it's output stream. I can reveal to you now that the function should ideally be called when your top level React component mounts.</p>
<pre class="language-tsx"><code class="language-tsx"><span class="highlight-line"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> Stream<span class="token punctuation">,</span> Subscription <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> run <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'frap'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// Imported from our main file</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> app<span class="token punctuation">,</span> State<span class="token punctuation">,</span> View<span class="token punctuation">,</span> startState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./main.ts'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">/** The state of our React component */</span></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">AppState</span> <span class="token punctuation">{</span></span><br>  state$<span class="token punctuation">:</span> Stream<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">State</span></span><span class="token punctuation">></span></span><span class="token plain-text">;<br><span class="highlight-line">  /** This holds our "real" app state ‚Äì ready to render! */</span><br><span class="highlight-line">  appState: State;</span><br><span class="highlight-line">}</span><br><span class="highlight-line"></span><br><span class="highlight-line">type Send = (event: View) => void;</span><br><span class="highlight-line"></span><br>class App extends React.Component&lt;any, AppState> </span><span class="token punctuation">{</span><br><span class="highlight-line">  <span class="token comment">/** Instance variable holding the subscription to the state stream. */</span></span><br><span class="highlight-line">  sub<span class="token punctuation">:</span> Subscription<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">/** Instance function used to drive messages into the view stream. */</span></span><br><span class="highlight-line">  send<span class="token punctuation">:</span> Send <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">    <span class="token comment">// Stream of input from the views.</span></span><br>    <span class="token keyword">const</span> view$ <span class="token operator">=</span> xs<span class="token punctuation">.</span>create<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">View</span></span><span class="token punctuation">></span></span><span class="token plain-text">();<br><span class="highlight-line"></span><br><span class="highlight-line">    // Create our "send" function which will drive messages on to</span><br><span class="highlight-line">    // the view stream above.</span><br>    this.send = (v: View) => </span><span class="token punctuation">{</span><br><span class="highlight-line">      view$<span class="token punctuation">.</span><span class="token function">shamefullySendNext</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br>    <span class="token punctuation">}</span><span class="token plain-text">;<br><span class="highlight-line"></span><br><span class="highlight-line">    // Kick everything off! üöÄ</span><br><span class="highlight-line">    const state$ = run(app, view$, startState);</span><br><span class="highlight-line"></span><br><span class="highlight-line">    // Attach on component's local state so we an access it</span><br><span class="highlight-line">    // in life cycle methods</span><br>    this.state = </span><span class="token punctuation">{</span><br><span class="highlight-line">      state$<span class="token punctuation">,</span></span><br><span class="highlight-line">      appState<span class="token punctuation">:</span> startState<span class="token punctuation">,</span></span><br>    <span class="token punctuation">}</span><span class="token plain-text">;<br><span class="highlight-line">  }</span><br><span class="highlight-line"></span><br>  componentDidMount(): void </span><span class="token punctuation">{</span><br><span class="highlight-line">    <span class="token comment">// Start subscribing to incoming state and set the local</span></span><br><span class="highlight-line">    <span class="token comment">// state of our React component. Will trigger re-render.</span></span><br><span class="highlight-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>sub <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>state$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><span class="highlight-line">      <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">appState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> appState <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">      <span class="token punctuation">}</span><span class="token punctuation">,</span></span><br><span class="highlight-line">      <span class="token function-variable function">error</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">      <span class="token punctuation">}</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br>  <span class="token punctuation">}</span><span class="token plain-text"><br><span class="highlight-line"></span><br>  componentWillUnmount(): void </span><span class="token punctuation">{</span><br><span class="highlight-line">    <span class="token comment">// Unsubscribe from state subscription:</span></span><br><span class="highlight-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>sub<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br>  <span class="token punctuation">}</span><span class="token plain-text"><br><span class="highlight-line"></span><br>  render(): React.ReactNode </span><span class="token punctuation">{</span><br><span class="highlight-line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> appState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">    <span class="token comment">// Render the 'name' state and a button to change it.</span></span><br><span class="highlight-line">    <span class="token keyword">return</span> <span class="token punctuation">(</span></span><br>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"><br><span class="highlight-line">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Hi </span><span class="token punctuation">{</span>appState<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token plain-text">!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text"></span><br><span class="highlight-line"></span><br><span class="highlight-line">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span></span><br>          <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span><br><span class="highlight-line">            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><span class="highlight-line">              kind<span class="token punctuation">:</span> <span class="token string">'set_name'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">              name<span class="token punctuation">:</span> <span class="token string">'Johnny Doe'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">            <span class="token punctuation">}</span><span class="token punctuation">)</span></span><br>          <span class="token punctuation">}</span></span><br><span class="highlight-line">        <span class="token punctuation">></span></span><span class="token plain-text"></span><br><span class="highlight-line">          Set another name</span><br><span class="highlight-line">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text"></span><br>      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><br><span class="highlight-line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span><br>  <span class="token punctuation">}</span><span class="token plain-text"><br><span class="highlight-line">}</span></span></code></pre>
<p>(The class approach is a bit verbose, but React Hooks is still a new concept which is outside the scope of this post. Here's a <a href="https://gist.github.com/brookback/d98efdfb4a3087dbba767910f2eec2f3">GitHub Gist</a> including a Hooks version).</p>
<p>Notice how we:</p>
<ol>
<li>Create a <code>view$</code> stream in the constructor and pass it to <code>run</code>.</li>
<li>Create a <code>send</code> function on the app component which can be used from view event handlers to send messages.</li>
<li>Subscribe to state updates when mounted.</li>
<li>Render the state in <code>render()</code>.</li>
</ol>
<p>The main fishy thing here might be the <code>shamefullySendNext</code> method in <code>send</code>. As from the <a href="http://staltz.github.io/xstream/#shamefullySendNext">docs</a>, this method forces a new value to be emitted to the stream. This is the one of the two &quot;bridges&quot; between our functional app world and the imperative view (the <code>subscribe()</code> call being the other one).</p>
<p>Phew. Lots of code and concepts. In this section, we've:</p>
<ul>
<li>seen how to add the view layer (here React) to our app architecture.</li>
<li>how to pass actual messages from the view.</li>
<li>render a React component from our state.</li>
</ul>
<p>There's one thing missing still. Where are all the async API calls, browser API functions, and logging utilities?</p>
<p>Yes: where are the <em>side effects</em>?</p>
<h2>Side effects üíÄ</h2>
<p>In any non-trivial application, there <em>will</em> be side effects. Side effects in this case refer to things similar to:</p>
<ul>
<li>Fetching JSON from an API server</li>
<li>Using Chrome's media APIs to gain access to the web camera</li>
</ul>
<p>The common denominator is that drivers include <em>imperative code</em>. Code that isn't functional streams. Code that affect the outside world. Code that is non-pure.</p>
<p>I recommend reading the <em>Drivers</em> section on <a href="https://cycle.js.org/drivers.html">CycleJS's page</a>, since we stole the concept of Drivers from there. There are many good examples there as well.</p>
<p>Once you've done that, return back here.</p>
<hr>
<p>We're gonna use the exact same concept of drivers in Frap. Drivers receive <em>Sinks</em> and return <em>Sources</em>. This is in contrast to our main app function, which receives <em>Sources</em> and returns <em>Sinks</em>.</p>
<p>The flow diagram thus becomes:</p>
<figure id="view-model">
  <img width="624" alt="Driver flow" src="/assets/posts/frap-driver-flow.png">
  <figcaption>App architecture with drivers and view.</figcaption>
</figure>
<p>Let's nail down our Sources and Sinks here.</p>
<ul>
<li><strong>To our <code>app</code> function,</strong> Sources are all input sources it needs to do its job. View messages, driver input, the state stream. Sinks are output instructions to drivers and state updates.</li>
<li><strong>To the drivers,</strong> Sources are the output instructions (as a stream) from <code>app()</code>. Sinks can be anything.</li>
</ul>
<p>The <code>run()</code> function from Frap takes care of glueing all of this together.</p>
<p>We communicate with the drivers with a single <em>out</em> stream with messages. A driver can thus look like:</p>
<p><strong>Driver</strong></p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token comment">// ConsoleLogDriver.ts</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> Stream <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">DoLog</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  kind<span class="token punctuation">:</span> <span class="token string">'do_log'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  label<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  args<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">type</span> ConsoleOut <span class="token operator">=</span> DoLog<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="token comment">/** A logging driver that consumes log messages and<br><span class="highlight-line"> * only performs writes to the console.</span><br> */</span><br><span class="highlight-line"><span class="token keyword">const</span> <span class="token function-variable function">ConsoleLogDriver</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">out$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>ConsoleOut<span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  out$</span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span> m <span class="token keyword">is</span> <span class="token parameter">DoLog</span> <span class="token operator">=></span> <span class="token operator">!</span><span class="token operator">!</span>m<span class="token punctuation">.</span>kind <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">'do_log'</span><span class="token punctuation">)</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token operator">...</span>m<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">default</span> ConsoleLogDriver<span class="token punctuation">;</span></span></code></pre>
<p>As you see, a driver is üåàJust A Function üåà.</p>
<p>This particular example of a driver only consumes sinks but doesn't return any sources back to our <code>app()</code> function.</p>
<p>How do we hook up this driver? We need to modify the <code>run</code> function!</p>
<p><strong>Run</strong></p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> xs <span class="token keyword">from</span> <span class="token string">'xstream'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">Sources</span><span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  view$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span><span class="token punctuation">;</span></span><br><span class="highlight-line">  drivers<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token punctuation">[</span>key<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span> <span class="token operator">|</span> Stream<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> run <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token parameter">main<span class="token punctuation">:</span> Main<span class="token punctuation">,</span> sources<span class="token punctuation">:</span> Sources<span class="token punctuation">,</span> startState<span class="token punctuation">:</span> State</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> view$<span class="token punctuation">,</span> drivers <span class="token punctuation">}</span> <span class="token operator">=</span> sources<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> fakeUpdates$ <span class="token operator">=</span> xs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> fakeDriverOuts <span class="token operator">=</span> <span class="token function">createFakeDriverOut</span><span class="token punctuation">(</span>drivers<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> state$ <span class="token operator">=</span> stateUpdate$<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prev<span class="token punctuation">,</span> update</span><span class="token punctuation">)</span> <span class="token operator">=></span></span><br><span class="highlight-line">    <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token operator">...</span>update <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> startState<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// The sources to our app: state, messages, and driver input</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> mainSources <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    state$<span class="token punctuation">,</span></span><br><span class="highlight-line">    view$<span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token operator">...</span><span class="token function">callDrivers</span><span class="token punctuation">(</span>drivers<span class="token punctuation">,</span> fakeDriverOuts<span class="token punctuation">)</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> stateUpdate$<span class="token punctuation">,</span> <span class="token operator">...</span>driverSinks <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span>mainSources<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  fakeUpdates$<span class="token punctuation">.</span><span class="token function">imitate</span><span class="token punctuation">(</span>stateUpdate$<span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">in</span> fakeDriverOuts<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token keyword">const</span> fake$ <span class="token operator">=</span> fakeDriverOuts<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class="highlight-line">    <span class="token keyword">const</span> driverOut$ <span class="token operator">=</span> driverSinks<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">    fake$<span class="token punctuation">.</span><span class="token function">imitate</span><span class="token punctuation">(</span>driverOut$<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">return</span> state$<span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p>This might look a bit hairy. I've left out the implementation of two functions here:</p>
<ul>
<li><code>createFakeDriverOut</code>. Similarily to the state updates, we need to have a cyclic relationship between the drivers' sinks and sources and the main app function. In this function, we create a fake stream for each driver specified.</li>
<li><code>callDrivers</code>. We call all the driver functions with the fake outputs and feed the drivers' returned output as sources to our main app function.</li>
</ul>
<p><strong>Main app</strong></p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token comment">// main.ts</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> run <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'frap'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> ConsoleOut <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./ConsoleLogDriver.ts'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">const</span> startState<span class="token punctuation">:</span> State <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token string">'Johan'</span><span class="token punctuation">,</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">SetName</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  kind<span class="token punctuation">:</span> <span class="token string">'set_name'</span><span class="token punctuation">;</span></span><br><span class="highlight-line">  name<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">export</span> <span class="token keyword">type</span> View <span class="token operator">=</span> SetName<span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">MainSources</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  view$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>View<span class="token operator">></span><span class="token punctuation">;</span></span><br><span class="highlight-line">  state$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>State<span class="token operator">></span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">interface</span> <span class="token class-name">MainSinks</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  stateUpdate$<span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>Partial<span class="token operator">&lt;</span>State<span class="token operator">>></span><span class="token punctuation">;</span></span><br><span class="highlight-line">  <span class="token builtin">console</span><span class="token punctuation">:</span> Stream<span class="token operator">&lt;</span>ConsoleOut<span class="token operator">></span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token keyword">const</span> app<span class="token punctuation">:</span> Main <span class="token operator">=</span> <span class="token punctuation">(</span>sources<span class="token punctuation">:</span> MainSources<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token parameter">MainSinks</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Access driver sources with:</span></span><br><span class="highlight-line">  <span class="token comment">//   sources.myDriver.*</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token keyword">const</span> stateUpdate$ <span class="token operator">=</span> <span class="token comment">/* updates to state */</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Send log message to log driver every second:</span></span><br><span class="highlight-line">  <span class="token keyword">const</span> logDriverOut$ <span class="token operator">=</span> xs</span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">periodic</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span></span><br><span class="highlight-line">    <span class="token punctuation">.</span><span class="token function">mapTo</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span><br><span class="highlight-line">      kind<span class="token punctuation">:</span> <span class="token string">'do_log'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">      label<span class="token punctuation">:</span> <span class="token string">'Hello!'</span><span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span><br><span class="highlight-line"></span><br><span class="highlight-line">  <span class="token comment">// Return sinks</span></span><br><span class="highlight-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token comment">// State updates as usual</span></span><br><span class="highlight-line">    stateUpdate$<span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token comment">// Output instructions to the console driver. The key</span></span><br><span class="highlight-line">    <span class="token comment">// needs to match the name of the driver specified in</span></span><br><span class="highlight-line">    <span class="token comment">// the `drivers` argument to `run` below.</span></span><br><span class="highlight-line">    <span class="token builtin">console</span><span class="token punctuation">:</span> logDriverOut$<span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span><br><span class="highlight-line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></code></pre>
<p><strong>View</strong></p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">import</span> ConsoleLogDriver <span class="token keyword">from</span> <span class="token string">'./ConsoleLogDriver.ts'</span><span class="token punctuation">;</span></span><br><span class="highlight-line"></span><br><span class="highlight-line"><span class="token comment">// In the react view, run our app:</span></span><br><span class="highlight-line"><span class="token function">run</span><span class="token punctuation">(</span></span><br><span class="highlight-line">  app<span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">{</span></span><br><span class="highlight-line">    view$<span class="token punctuation">,</span></span><br><span class="highlight-line">    drivers<span class="token punctuation">:</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">      <span class="token comment">// ... with the console log driver function</span></span><br><span class="highlight-line">      <span class="token builtin">console</span><span class="token punctuation">:</span> ConsoleLogDriver<span class="token punctuation">,</span></span><br><span class="highlight-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span><br><span class="highlight-line">  startState</span><br><span class="highlight-line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre>
<hr>
<p>That's it! Now we can handle all side effects in their special drivers, where they can do all kinds of reads and writes with the external world, and safely pass back their results as sources (&quot;input&quot;) to our app.</p>
<h2>Parting words</h2>
<p>We're approaching the end of the background of Frap. I might've breezed over some concepts and I might've done a terrible job trying to convey the flows. If that's the case, please let me know at <a href="mailto:johan@johanbrook.com">johan@johanbrook.com</a> or at <a href="https://twitter.com/johanbrook">@johanbrook</a>.</p>
<p>A huge shoutout to the creators of CycleJS. We've been inspired by them in just about everything. Thanks for popularising the ideas of cyclical data flows!</p>
<hr>
<p>What I love about this architecture we've just built are these things:</p>
<ul>
<li>Reasoning in reactive streams! üòç Forget about mutability and writing imperative code. Say hello to declarative code and &quot;tight&quot; business logic.</li>
<li>How well it goes along with React's virtual DOM nature.</li>
<li>How the architecture is flexible enough to allow for all varieties of organising your app, still being strict with what types you pass around.</li>
<li>How well it scales. Almost every new feature you'll add to your app will be written in the same style.</li>
<li>How safe I feel when everything from the library layer (Frap) to the view layer (React) is handled with a type system (Typescript).</li>
</ul>
<p>Please go ahead and read the full API and documentation on the Frap GitHub page:</p>
<p class="tc">
  <a href="https://github.com/lookback/frap" class="btn">lookback/frap</a>
</p>
<p class="tc">
  <strong>Thank you so much for reading ‚ú®</strong>
</p>
