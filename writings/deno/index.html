<!DOCTYPE html>
<html lang="en-gb" class=" writingsdeno"><head itemtype="http://schema.org/Blog" itemscope="">
    <title>A whole new world with Deno / Johan Brook</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://gc.zgo.at">
    <link rel="preconnect" href="https://johanbrook.goatcounter.com">

    
    <meta name="description" content="How I started to like programming in Javascript again thanks to Deno – a Rust based Javascript runtime which also runs Typescript.">
    
    
    <meta name="keywords" content="deno,node,typescript,javascript">
    
    <meta name="author" content="Johan Brook">

    <!-- Styles-->
    <link rel="stylesheet" href="/johan.css">

    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Posts feed (Atom)" href="/writings.xml">
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Micro feed (Atom)" href="/micro.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Micro feed (JSON)" href="/micro.json">
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Book feed (Atom)" href="/reading.xml">

    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <link rel="canonical" itemprop="url" href="https://johan.im/writings/deno/">
    <link rel="author" href="https://johan.im">
    <link rel="me" href="https://hachyderm.io/@brookie">

    <meta property="og:title" content="A whole new world with Deno">
    <meta property="og:url" content="https://johan.im/writings/deno/">
    <meta property="og:site_name" itemprop="name" content="Johan Brook">
    
    <meta property="og:locale" content="en_GB">
    
    <meta property="og:description" content="How I started to like programming in Javascript again thanks to Deno – a Rust based Javascript runtime which also runs Typescript.">
    

    
    <meta property="article:modified_time" content="2022-02-08T00:00:00Z" itemprop="dateModified">
    

    
	<meta property="og:type" content="article">
    <meta property="article:tag" content="deno,node,typescript,javascript">
    <meta property="article:published_time" content="2022-01-19T00:00:00Z">
   	
  </head>

  <body>
  	  <a href="#main" class="visually-hidden skip-link">Skip to content</a>
	  <div class="Content">
	  	<div id="main">
			<main role="main">
  <article class="Post" role="article" itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 itemprop="name" class="title">A whole new world with Deno</h1>

      <p class="mb0 fw5">
          <time class="text-color-contrast" datetime="2022-01-19T00:00:00Z" title="2022-01-19T00:00:00Z" itemprop="datePublished" pubdate="">
            January 19th, 2022
          </time>
          
            <time title="Updated at" class="muted normal ml-1" datetime="2022-02-08T00:00:00Z" itemprop="dateModified">
                (updated February 8th, 2022)
            </time>
          
          
      </p>

      <p class="f5 mb4 font-sans muted">
          About 6 min reading time
      </p>
    </header>

    <div class="prose" itemprop="articleBody">
      
      <p><a href="https://deno.land">Deno</a> is a new <em>runtime</em> for Javascript. Before, NodeJS used to be the most
popular way to run Javascript on the server. But no more! Deno has reached stable state (it’s on
version 1.17 at the time of writing). It runs Typescript natively, supports ES imports (why did I
feel I had to specify that as a feature?), and is built with Rust (again! This isn’t a feature, but
it feels good that it’s Rust somehow, doesn’t it?).</p>
<p>Until now, I’ve just read the <a href="https://deno.land/manual">Deno manual</a> and lurked in their
<a href="https://deno.land/std">standard library</a>. Then I played around with a server + client app for a
couple of days, and after that I converted this site to use <a href="https://lumeland.github.io">lume</a>,
which is a static site generator based on Deno.</p>
<p>Here are some of my personal favourites in Deno, with some love for lume as an appendix.</p>
<h1>Web APIs we know and love</h1>
<p>Deno includes a ton of niceties that just sparks joy for the hardest of the hardcore NodeJS
developers out there. <code>fetch</code> <em>just works</em> (we’ve internalised that one needs to <code>npm install</code> some
external library for HTTP requests in NodeJS). Hell, even doing the very browser-y <code>alert</code> and
<code>confirm</code> in your Deno based CLI script will work on the command line to show a message and prompt
for yes/no, respectively. Opinions might differ whether this is good or bad, but personally I
appreciate not having to pull in a lib or visit StackOverflow each time I need user input.</p>
<blockquote>
<p>For APIs where a web standard already exists, like fetch for HTTP requests, Deno uses these rather
than inventing a new proprietary API.</p>
</blockquote>
<p>The above line from <a href="https://deno.land/manual/runtime">“The Runtime”</a> section of the Manual is the
red line throughout the Deno API.</p>
<p>That means, instead of doing</p>
<pre><code class="language-ts">// Node
import request from 'some-random-npm-request-lib';

const response = await request.get('https://deno.land');
</code></pre>
<p>you’d do</p>
<pre><code class="language-ts">// Deno/browsers
const response = await fetch('https://deno.land');
</code></pre>
<p>In Deno, you can use a ton of browser-y APIs, such as <code>location</code>, <code>local/sessionStorage</code>,
<a href="https://deno.land/manual@v1.17.3/runtime/web_platform_apis#other-apis">and more</a>.</p>
<p>Another example: you can use the same CSS based styling for <code>console</code> calls as you’d do in the
browser:</p>
<pre><code class="language-ts">// Deno/browsers
console.log(
	'%cHi there. %cSome background?',
	'color: red',
	'background-color: gray',
);
</code></pre>
<p>No need for terminal escape codes or pulling in yet another library.</p>
<p>I hope it’s clear where I’m getting at: there are things included in Deno that you <em>just know
already</em> because you’ve been writing web code for years. It lowers the iteration speed when writing
code, as well as lowers the overhead when reading it, when you don’t have to refer to third party
dependencies or in-house modules all the time. To me, this feels much better when writing code in
Deno.</p>
<p>The use of third party dependencies have been a debate in Javascript land during the past couple of
months, due to … incidents around security and feelings of the module authors themselves. Surely the
best dependency is no dependency, right? Surely a ton of npm modules can be deprecated if only
NodeJS (or Javascript itself) had a better standard library?</p>
<p>I hope that we in the future look at “old” code and say: “Oh, did you pull in a dependency for
<em>that</em>?”.</p>
<p><strong><em>Update, 2022-02-08:</em></strong> the Deno authors have written a neat
<a href="https://deno.com/blog/every-web-api-in-deno">blog post</a> detailing all web platform APIs implemented
in Deno, with examples. You’ll get a very fuzzy feeling when reading the list.</p>
<h1>Typescript as a first class citizen</h1>
<p>I was in tears (tears of joy, I assure you) when I first read about Typescript support in Deno when
the latter was introduced years ago. No need for a build step for <code>.ts</code> and <code>.tsx</code> files, just
<code>deno run</code> and off you go. I just works.</p>
<p>One neat API is <a href="https://deno.land/manual/typescript/runtime"><code>Deno.emit</code></a>. With it, you can
programmatically compile and bundle Typescript code to Javascript.</p>
<p>I’ve got not much more to say about this than <em>“Finally”</em>.</p>
<h1>Testing</h1>
<p>Let’s play a game. How many test runners for Javascript code can you think of?</p>
<p>…</p>
<p>Okay, tough question, as the correct answer probably is: “The number is approaching <code>Infinity</code>″.</p>
<p>How many test runners do you <em>need</em>? One. There’s one built-in in Deno:</p>
<pre><code class="language-ts">Deno.test('My test', () =&gt; {
	// test things
});
</code></pre>
<p>Name the file <code>something.test.ts</code> and run it with:</p>
<pre><code class="language-bash">deno test something.test.ts
</code></pre>
<p>I love this. Standardised, one way of doing things, minimal. No arguing in the team about which is
the best test runner this month.</p>
<p>The <a href="https://deno.land/std/testing"><code>testing</code></a> module from the Deno std lib includes a couple of
assertions — you probably don’t need more than those. (I also see it exports tools for benchmarking
your code as well, iihhh!)</p>
<h1>Distributed dependency management</h1>
<p>…with no <code>package.json</code>! In Deno, you import external, remote, dependencies with URLs. Again, just
like we’ve done in the browser since the 90s (<code>&lt;script src="http://cdn.example.com/script.js&gt;</code>
amirite). When Deno first runs your code, it’ll fetch the remote script and cache it locally for the
next runs. Don’t be scared: Deno do support reading and writing a lockfile with options to
<code>deno run</code>.</p>
<p>This is how it looks like:</p>
<pre><code class="language-ts">import dependency from 'https://somesite.com/mod.ts';
</code></pre>
<p>(By convention, modules should have a <code>mod.ts</code> which is the entrypoint for consumers. Note that
there’s no concept of some silly <code>index.js</code> file in Deno land: that’s one thing the Node creator
Ryan wanted to get rid of when he created Deno.)</p>
<p>This is actually fairly liberating once you’ve sweated out the feelings of chaos in your codebase.
Remember, this is all source code! You can centralise all these third party imports to a single file
and re-export them. In fact, that’s what
<a href="https://deno.land/manual@v1.18.0/linking_to_external_code#it-seems-unwieldy-to-import-urls-everywhere">they recommend in the Deno Manual</a>:</p>
<pre><code class="language-ts">// deps.ts (naming convention!)
export * as assert from 'https://deno.land/std@0.122.0/testing/asserts.ts';
</code></pre>
<p>“Sooo how do I get my fav npm hosted lib into my Deno code then?”, you ask.</p>
<ol>
<li>Check <a href="https://deno.land/x">deno.land/x</a> if the module is hosted there. There are a lot of Deno
specific modules.</li>
<li>Import from any of the services below.</li>
</ol>
<p>Services reading from npm:</p>
<ul>
<li><a href="https://www.skypack.dev">Skypack</a></li>
<li><a href="https://esm.sh">esm.sh</a></li>
<li><a href="https://unpkg.com">unpkg.com</a></li>
<li><a href="https://cdnjs.com">cdnjs.com</a></li>
</ul>
<p>Skypack and esm.sh will actually bundle code from npm into modern ES module syntax. Both of them are
Deno friendly.</p>
<p>The beauty with these is that if one of them is failing, or if you’re unhappy with the service, you
can just switch out the URL imports in your <code>deps.ts</code>.</p>
<p>Tip: with Skypack and esm.sh (from what I know) you get Typescript types too. esm.sh will do this
automatically, and with Skypack you can append a <code>?dts</code> query parameter to the imported URL. See
their respective config query parameters: it’s super cool what they can do these days.</p>
<p>One thing that tripped me up was that it’s not always easy to find a suitable entrypoint file when
importing via URLs. Deno friendly modules has a <code>mod.ts</code> in the repo somewhere, but often you have
to hunt down a file yourself.</p>
<h2>Import maps</h2>
<p>I’ve glossed over the technology that is <a href="https://github.com/WICG/import-maps">Import Maps</a>. In my
own words, I’d say it’s a file where you specify from where the source code’s <code>import</code> statements
should look for the code to be imported. In a way, it’s emulating npm’s way of looking in
<code>node_modules</code>, but this is even more powerful.</p>
<p>If you were annoyed over importing “raw” URLs in the section above, this will save you!</p>
<p><strong>Import map</strong></p>
<pre><code class="language-json">{
	"imports": {
		"react": "https://esm.sh/react@17.0.2"
	}
}
</code></pre>
<p><strong>Source code</strong></p>
<pre><code class="language-ts">import React from 'react';
</code></pre>
<p>Remember to specify <code>--import-map</code> for <code>deno run</code>! Nothing in Deno is implicit: it won’t pick up the
import map by itself.</p>
<h1>Summary</h1>
<p>My overall impression of Deno that while it’s new technology, it’s quite mature and well documented.
And if you’ve got a hairy question, you can pop into their Discord server and ask there. The <code>std</code>
modules are very modern in the way they’re written (compared to Node, which <em>just</em> got Promise based
APIs…). It’s actually fun to write Javascript code again. I’d attribute that to the decrease of
“Javascript fatigue” in Deno, since there are so many built-in modules you’d previously assume you’d
need to get from a third party.</p>
<p><strong>When</strong> (hehe) you install Deno, be sure to do <code>deno help</code> in a terminal to see the range of nice
sub commands. <code>deno types</code> and <code>deno doc</code> are favourites of mine. <code>deno compile</code> is also cool if
you’re writing a script which should be run as a self contained executable, suitable for
distribution.</p>
<h1>Appendix: lume</h1>
<p><a href="https://lumeland.github.io">lume</a> is a static site generator, built with Deno. I read through the
documentation and jumped around in the source code for a while before I fell in love and ported
johanbrook.com to it.</p>
<p>Lume is a joy to work with. The built-in functionality and plugins fill 95% of my use cases — very
little custom code needed. And <em>if</em> I don’t understand the documentation, reading the source code is
no problem.</p>
<p>It <em>feels</em> easier to use than other generators I’ve tried (Jekyll, Middleman, Metalsmith, Eleventy)
but yet very powerful. During the porting my code I was not too annoyed during the process:
something that you easily get when trying a brand new site generator. The fact that its written in
Typescript is <em>so</em> nice, as you get static typing and don’t have to guess what objects and
properties to read.</p>
<p>Try it out!</p>

    </div>
  </article>
</main>

		</div>

		
	   		<nav role="navigation" class="MainNav">
	<div class="sticky">
		<h1 class="f4 sr-only-mobile">
			<a href="/" aria-label="Home">
				<span>Johan Brook</span><span aria-hidden="true" class="BackLink ml2">←</span>
			</a>
		</h1>

		<ul>
           	<li class="only-mobile">
          		<a href="/">Home</a>
           	</li>
          		<li>
         			<a href="/now/">Now</a>
          		</li>
          		<li>
         			<a href="/mind/">Micro</a>
          		</li>
          		<li>
         			<a href="/about/">About</a>
          		</li>
          		<li>
         			<a href="/reading/">Reading</a>
          		</li>
          		<li>
         			<a href="/feeds/">Feeds</a>
          		</li>
          		<li>
         			<a href="/writings/">Writings</a>
          		</li>
            <li class="border border-t mt1 pt1">
     			<a href="/all">All pages</a>
      		</li>
        </ul>
	</div>
</nav>

	 	
	  </div>

      <script>
  // Only load on production environment.
  if (window.location.host !== new URL('https://johan.im').host) {
    window.goatcounter = {no_onload: true};
  }

  // Skip own views
  if (window.location.hash === '#skipgc')
    localStorage.setItem('skipgc', 't');
  if (localStorage.getItem('skipgc') === 't')
    window.goatcounter = {no_onload: true};
</script>
<script data-goatcounter="https://johanbrook.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>

  


</body></html>