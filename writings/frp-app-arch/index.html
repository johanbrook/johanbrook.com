<!DOCTYPE html>
<html lang="en-gb" class=" writingsfrp-app-arch"><head itemtype="http://schema.org/Blog" itemscope="">
    <title>Building a small, functional reactive app architecture / Johan Brook</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://gc.zgo.at">
    <link rel="preconnect" href="https://johanbrook.goatcounter.com">

    
    <meta name="description" content="A long-ish read on how to build a web frontend with reactive functional streams (in Typescript!). We'll go through how we at Lookback extracted a library from patterns in our frontend, inspired by the library CycleJS.">
    
    
    <meta name="keywords" content="typescript,streams,react,frp,reactive">
    
    <meta name="author" content="Johan Brook">

    <!-- Styles-->
    <link rel="stylesheet" href="/johan.css">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Posts feed" href="/feed.xml">
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Mind feed" href="/mind.xml">
    <link rel="alternate" type="application/atom+xml" title="Johan Brook: Book feed" href="/reading.xml">

    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <link rel="canonical" itemprop="url" href="https://johan.im/writings/frp-app-arch/">
    <link rel="author" href="https://johan.im">
    <link rel="me" href="https://hachyderm.io/@brookie">

    <meta property="og:title" content="Building a small, functional reactive app architecture">
    <meta property="og:url" content="https://johan.im/writings/frp-app-arch/">
    <meta property="og:site_name" itemprop="name" content="Johan Brook">
    
    <meta property="og:locale" content="en_GB">
    
    <meta property="og:description" content="A long-ish read on how to build a web frontend with reactive functional streams (in Typescript!). We'll go through how we at Lookback extracted a library from patterns in our frontend, inspired by the library CycleJS.">
    

    

    
	<meta property="og:type" content="article">
    <meta property="article:tag" content="typescript,streams,react,frp,reactive">
    <meta property="article:published_time" content="2020-05-01T00:00:00Z">
   	
  </head>

  <body>
  	  <a href="#main" class="visually-hidden skip-link">Skip to content</a>
	  <div class="Content">
	  	<div id="main">
			<main role="main">
  <article class="Post" role="article" itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 itemprop="name" class="title">Building a small, functional reactive app architecture</h1>

      <p class="mb0 fw5 mt3">
          <time datetime="2020-05-01T00:00:00Z" itemprop="datePublished" pubdate="">
            May 1st, 2020
          </time>
          
          
      </p>

      <p class="f5 mb4 font-sans muted">
          About 18 min reading time
      </p>
    </header>

    <div class="prose" itemprop="articleBody">
      
      <p>At <a href="https://lookback.io">Lookback</a>, we‚Äôve fallen in love with functional reactive programming (FRP)
with streams in our frontend apps. Together with the use of Typescript for compile time type safety,
we‚Äôve seen a tremendous bump in overall stability and fewer runtime bugs. Actually, I dare to say
that <em>all</em> of our bugs so far have been either logic (programmer) or timing errors.</p>
<h2>What this text is and what it‚Äôs not</h2>
<p>We‚Äôll look at how <em>easy</em> it actually is to build these kind of frontend architectures on your own.
This architecture is, to be clear, <em>not</em> any new or novel idea at all. As you will read below, it‚Äôs
essentially a rip-off of a library called CycleJS, but less general and made to work with React as a
view before CycleJS had proper React support.</p>
<p>What we‚Äôll go through is how one can reason about state, side effects, and drawing the view with the
data structure streams. In the end, we have the complete library.</p>
<p><strong>I‚Äôll assume knowledge about streams in this post.</strong> With ‚Äústreams‚Äù, I don‚Äôt mean the
<a href="https://nodejs.org/api/stream.html">NodeJS Stream API</a>, but the functional streams popularised by
libraries such as RxJS, BaconJS, and xstream. The xstream library will be used for reactive streams,
but the concepts are applicable to any streams implementation with the basic operations. I will also
use Typescript features to model the architecture.</p>
<p>An architecture based on functional reactive stream isn‚Äôt for all frontend apps. Vanilla React
paired with the Context API a reducer is probably fine in most cases. We use FRP in our Live player,
and in our Chrome extension. Both codebases need to handle the complexities of multi-peer
audio/video streaming, fetching data from a GraphQL API, client state, server state, connection
problems, interrupts, problems with the mic and camera, subscribing to server data. Even with
Typescript, I wouldn‚Äôt want to model that in a Flux based React application. FRP has helped us
handle the data flows in a concise manner across the app, with the help from cozy declarative
constructs as <code>map</code>, <code>filter</code>, and so on. It‚Äôs pretentious to say, but I almost feel ‚Äúthe code
writes itself‚Äù when building out the streams for the data flows.</p>
<h2>The code</h2>
<p><strong>This is not some kind of new framework.</strong> Many others already exist. The repository linked below
is solely for demonstration, and to hold the final code:</p>
<p class="tc">
  <a href="https://github.com/lookback/frap" class="btn">‚ú® lookback/frap on GitHub</a>
</p>
<ul>
<li><em>frap</em> is for <strong>F</strong>unctional <strong>R</strong>eactive <strong>Ap</strong>plication.</li>
<li>üî® ~20 Kb minified.</li>
<li>üìâ Has a single dependency (the <code>xstream</code> library).</li>
<li>üèÑ‚Äç‚ôÇÔ∏è The core API consists of two functions.</li>
<li>ü§ù Agnostic about the view, but assumes a stream based application.</li>
</ul>
<h2>Why?</h2>
<p>For me personally, it was all about the joy of constructing an architecture I could understand the
smallest parts of, and then extracting it to make it general.</p>
<p>It also felt good not using a 3rd party package, except for <code>xstream</code>, to solve a thing.</p>
<h2>Credits</h2>
<p>The main brain behind the architecture is my colleague <a href="https://twitter.com/algstn">Martin</a>. He was
the drive behind the functional patterns as we pair programmed to build the architecture for
Lookback‚Äôs Live player. The extraction and generalisation was made by me. As mentioned, the
extraction and this post serves as a learning experience for myself too.</p>
<h2>Background</h2>
<p>We do make use of <a href="https://cycle.js.org">CycleJS</a> in one of our web clients. CycleJS introduced the
concept of cyclical streams and <em>drivers</em> for side effects for us. Go ahead and read about all its
features on the website. It was a bit daunting for me in the beginning to ‚Äúthink in cyclical
streams‚Äù, but a few months in I‚Äôm happier than ever building a single page client app.</p>
<p>I recommend reading these texts on streams and reactive programming:</p>
<ul>
<li><a href="https://cycle.js.org/streams.html">‚ÄúStreams‚Äù on CycleJS.org</a></li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">‚ÄúThe introduction to Reactive Programming you‚Äôve been missing‚Äù</a>
by Andr√© Staltz, creator of xstream and CycleJS.</li>
<li><a href="https://futureofcoding.org/papers/comprehensible-frp/comprehensible-frp.pdf">‚ÄúExplicitly Comprehensible Functional Reactive Programming (pdf)‚Äù</a></li>
</ul>
<p>Have a look at the CycleJS documentation and guides. Then let‚Äôs see why we decided to <em>not</em> go with
CycleJS for a new single page app.</p>
<h3>Differences in drawing a DOM</h3>
<p>Out-of-the-box, CycleJS uses <a href="https://github.com/snabbdom/snabbdom">Snabbdom</a>‚Äâ‚Äî‚Äâa virtual DOM
library‚Äâ‚Äî‚Äâto build your app‚Äôs HTML and insert into the browser. CycleJS supports
<a href="https://cycle.js.org/components.html">components</a>, i.e. reusable functions that emit a DOM and take
props.</p>
<p>A component in CycleJS/Snabbdom might look like this:</p>
<pre><code class="language-typescript">import xs from 'xstream';
import { div, input, span } from '@cycle/dom';

function MyComponent(sources) {
	// Incoming DOM from the outside:
	const domSource = sources.DOM;

	// Stream of new text values from our &lt;input&gt; element
	const newValue$ = domSource
		.select('.input') // The &lt;input&gt; has class="input"
		.events('input') // Listen to `input` events
		.map((ev) =&gt; ev.target.value); // For each input, grab the `value`

	// Build a stream of state, which looks like:
	//  Stream&lt;{ value: string }&gt;
	const state$ = newValue$.map((value) =&gt; ({ value })).remember(); // Remember last value

	// Render out the UI from our state using Snabbdom. This is
	// a virtual DOM implementation, and we build the structure
	// using Hyperscript.
	const vdom$ = state$.map((state) =&gt;
		div([
			span(state.value),
			input('.input', {
				attrs: { type: 'text' },
			}),
		])
	);

	// Finally, return our DOM to the outside, along with the
	// values from our &lt;input&gt;
	return {
		DOM: vdom$,
		value: state$.map((state) =&gt; state.value),
	};
}
</code></pre>
<p>The DOM flows through the component as a <em>stream</em>. Compare this with a React component where you
return the virtual DOM as a lump of JSX:</p>
<pre><code class="language-tsx">import React, { useState } from 'react';

function MyComponent() {
	const [text, setText] = useState&lt;string&gt;('');

	return (
		&lt;div&gt;
			&lt;span&gt;{text}&lt;/span&gt;
			&lt;input
				type='text'
				defaultValue={text}
				onInput={(evt) =&gt; setText(evt.target.value)}
			/&gt;
		&lt;/div&gt;
	);
}
</code></pre>
<p>The React component <em>probably</em> looks more straight forward to most people than the CycleJS
component, I imagine. It‚Äôs because it‚Äôs <em>imperative</em>. We use <code>setText</code> and perhaps <code>this.setState</code>
in React components‚Äâ‚Äî‚Äâa concept that doesn‚Äôt exist in CycleJS‚Äôs world. In CycleJS, something needs
to ‚Äúpull‚Äù the values through the streams through the component. Streams are, aptly, flowing through
the whole app.</p>
<h3>Building our own</h3>
<p>I think the Snabbdom way of building markup is interesting. It encourages me to think about my
frontend code as functions even more (JSX sort of hides that away). For a rewrite of our Live
player, we decided we wanted to use React for the view, instead of doing full CycleJS/Snabbdom
again. This was before <a href="https://github.com/cyclejs/react">@cycle/react</a> was released, so we set out
to fully ditch CycleJS for this rewrite and figure out how to make business logic in streams play
well with React for the view.</p>
<p>The choice of React for the view was partly due to some odd quirks in how CycleJS handles DOM
events, and partly due to the nice React ecosystem. Typescript and React go perfect together too,
making for robust view components.</p>
<p>In our new architecture, we wanted to keep these concepts from CycleJS:</p>
<ul>
<li>All business logic as reactive streams.</li>
<li>Handling side effects in Drivers, making for a ‚Äúpure‚Äù main application.</li>
</ul>
<p>We wanted to get rid of:</p>
<ul>
<li>Replace the DOM-as-a-stream and Snabbdom rendering with React.</li>
</ul>
<p>We also wanted to include:</p>
<ul>
<li>Storing the whole app state as a central atom and draw the whole user interface based on that. Of
course very common in the React world these days.</li>
</ul>
<p>Let‚Äôs begin!</p>
<h2>Table of Contents</h2>
<ol>
<li>State &amp; data flow</li>
<li>State updates</li>
<li>Sending messages</li>
<li>The view</li>
<li>Side effects</li>
</ol>
<h2>State &amp; data flow</h2>
<p>How to manage state in frontend applications has turned out to be a hot topic. What is app state
anyway? It might be:</p>
<ul>
<li>An ID string of the currently signed in user.</li>
<li>An array of blog posts.</li>
<li>A boolean indicating if a modal is open or not.</li>
<li>An enum for the current state in a state machine.</li>
</ul>
<p>And so on. The basic idea is that we should be able to <strong>draw the whole interface from this state</strong>.
Sometimes, using local state in components is fine. This might be state such as the active tab in a
tab system, which is very local, and <em>probably</em> doesn‚Äôt concern any other parts of the system.</p>
<p>Redux popularized the Flux architecture‚Äôs idea of state as ‚Äúsingle source of truth‚Äù. We shouldn‚Äôt
scatter the state across DOM nodes, localStorage, the server, and so on. Also Elm and Om are great
inspiration for state handling in client side apps. I encourage you to read the
<a href="https://redux.js.org/introduction/motivation">philosophies and principles of Redux</a>.</p>
<p>A state atom might look like this:</p>
<pre><code class="language-typescript">const state: State = {
	name: 'Johan Brook',
	showModal: true,
};
</code></pre>
<p>From this, we should be able to draw the full app component tree. And if we‚Äôd draw it again from the
same state, the app‚Äôs UI can‚Äôt change fundamentally.</p>
<hr>
<p>A core principle of functional programming is immutability‚Äâ‚Äî‚Äâthe inability to change a state after
it‚Äôs created. We‚Äôd like our app state to work the same. Meaning, we can‚Äôt just ‚Äúset a property in
the state‚Äù like it‚Äôs the Wild West.&nbsp;We need to update properties incrementally and generate a ‚Äúnew‚Äù
state. For each of these state updates, the view should re-draw.</p>
<p>In order to update the <code>name</code> in our state, we can design the flow like this:</p>
<ol>
<li>Construct your update to the state atom. In this case <code>{ name: 'John Doe' }</code>.</li>
<li>Send the update as a stream to a function which folds it together with the state stream:</li>
</ol>
<pre><code class="language-typescript">const state$ = stateUpdate$.fold(
	(prev, update) =&gt; ({ ...prev, ...update }),
	startState,
);
</code></pre>
<p>The xstream function <a href="http://staltz.github.io/xstream/#fold"><code>fold</code></a> is very handy to learn here.
That‚Äôs the amazing function which creates our whole incremental state! The update effectively
extends the existing state object to form a new one.</p>
<p>So we‚Äôve got a <code>state$</code> variable containing the <em>stream of states</em>. It‚Äôs very important to
internalise that the ‚Äústream of states‚Äù here isn‚Äôt a continuous stream, but a discrete one. It‚Äôs a
like a string with ants, where each ant is a new state, and they can come in irregular patterns. The
idea is to let the view listen to this <code>state$</code> stream, which will behave like this:</p>
<pre><code>stateUpdate$ = ---------- update: { name: 'Johnny Doe' }----

stateUpdate$.fold(..., startState)

state$ = ---{ name: 'Johan Brook' }--{ name: 'Johnny Doe' }-
</code></pre>
<p>For each new element in the resulting <code>state$</code> stream, we‚Äôll re-render the whole app (read more
below about how we‚Äôll manage the view).</p>
<p>So what are these state updates? It‚Äôs ‚ú®<strong>your application</strong> ‚ú®! That‚Äôs right: all business logic will
either result in state updates or side effects (read more about that in the section about Drivers
below).</p>
<p>This can be expressed roughly like this (with xstream):</p>
<pre><code class="language-typescript">import { Stream } from 'xstream';

interface State {
	name: string;
	showModal: boolean;
}

// Our app just returns a new `name` instantly, but here
// we would render our entire app as React components or similar.
const app = (state$: Stream&lt;State&gt;) =&gt; {
	return state$.map((state) =&gt; ({
		name: 'Mary',
	}));
};

const run = (main: Main, startState: State) =&gt; {
	// Create an incrementally updated stream of state
	// XXX Fix stateUpdate$
	const state$ = stateUpdate$.fold(
		(prev, update) =&gt; ({ ...prev, ...update }),
		startState,
	);

	// Main app function, renders UI from state$ stream
	main(state$);
};

// Kick off! üöÄ
run(app, { name: 'Johan', showModal: false });
</code></pre>
<p>Sharp eyed readers notice that <code>stateUpdate$</code> is appearing out of nowhere. That‚Äôs supposed to come
from the app function, right?! Here‚Äôs what the ‚Äúcyclical‚Äù in CycleJS comes in: we need to cycle back
the state updates from our app up to the <code>fold</code> operation. Luckily, the xstream library has an
<a href="http://staltz.github.io/xstream/#imitate"><code>imitate</code></a> method on a stream which makes it possible to
create a fake stream at the top of a function, run operations on it, and then let it imitate a
‚Äúreal‚Äù stream further down the file. This allows circular dependency of streams.</p>
<p>Let‚Äôs fix our code:</p>
<pre><code class="language-typescript/5,12-17/">import xs from 'xstream';

const run = (main: Main, startState: State) =&gt; {
  // Create "fake", empty update stream
  const fakeUpdates$ = xs.create();

  const state$ = fakeUpdates$.fold(
    (prev, update) =&gt; ({ ...prev, ...update }),
    startState
  );

  const appUpdate$ = main(state$);

  // Imitate the real state update stream - results are
  // cycled back to the .fold operation above!
  fakeUpdates$.imitate(appUpdate$);

  return state$;
};
</code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#create">Docs on <code>xs.create</code></a></p>
<p>We‚Äôve successfully achieved feeding our app with a stream of state, and made the output stream of
the app update the state! üéâ This creates a <code>main</code> function signature of:</p>
<pre><code class="language-typescript">type Main = (state$: Stream&lt;State&gt;) =&gt; Stream&lt;Partial&lt;State&gt;&gt;;
</code></pre>
<p>Thus, state management is ticked off. You just need to provide the <code>main</code> function which is your
whole app logic.</p>
<p>Takeaways:</p>
<ul>
<li>We update our state with updates via a stream.</li>
<li>Our main app function <em>takes a state stream</em> and <em>returns an update stream</em>.</li>
<li>The state is thus incrementally updated.</li>
<li>The view is re-rendered each time the state updates.</li>
</ul>
<h2>Ch..ch..changes ‚Ä¶ (to the state)</h2>
<p>Let‚Äôs explore the <code>run</code> function from the earlier example. This code below demonstrates how you
would use it in an app. The <code>run</code> function is thus an export of our library:</p>
<pre><code class="language-typescript">// run :: (Main, State) -&gt; Stream&lt;State&gt;
import { run } from 'frap';

interface State {
	name: string;
}

const startState: State = {
	name: 'Johan',
};

// Our app's business logic, packaged in a single function.
// Receives state stream and should return a stream of updates
// to the state.
// app :: (Stream&lt;State&gt;) -&gt; Stream&lt;Partial&lt;State&gt;&gt;
const app: Main = (state$: Stream&lt;State&gt;) =&gt; {
	const stateUpdate$ = xs.create();

	return stateUpdate$;
};

// Kick it off! üöÄ
run(app, startState);
</code></pre>
<p>That <code>app</code> function is basically everything there is to it! (almost‚Ä¶ we just need to sort out the
view rendering and handle side effects). We receive state, do stuff deriving off of it, and return
our preferred updates.</p>
<p>An example could be:</p>
<pre><code class="language-typescript/2-5/">const app: Main = (state$: Stream&lt;State&gt;) =&gt; {
  const stateUpdate$ = state$.map((state) =&gt; ({
    name: state.name.toUpperCase(),
  }));

  return stateUpdate$;
};
</code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#map">Docs on <code>map</code></a></p>
<p>This little app of ours would instantly update the <code>name</code> property in our state atom to uppercase:</p>
<pre><code>--- { name: 'Johan' } ---
  app()
--- { name: 'JOHAN' } ---
</code></pre>
<p>Now, this seems silly and simplistic. I thought so too. ‚ÄúHow can I ever achieve complex app logic
with this?!‚Äù. Turns out you can. By using the stream operators of xstream on your data, you really
<em>can</em> achieve crazy things. It all adds up. For me, it was all about separating the big state down
into small functions taking care of ‚Äútheir‚Äù domain, and then merging it all together:</p>
<pre><code class="language-typescript">// Functions we've written to take care of stuff in our data model.
// We don't care how they do it ‚Äì as long as their return a stream
// of state updates.
import { nameUpdate, posts } from './lib';

const app: Main = (state$: Stream&lt;State&gt;) =&gt; {
	const nameUpdate$ = nameUpdate(state$);
	const postsUpdate$ = posts(state$);

	// All derived state updates off of existing state
	return xs.merge(nameUpdate$, postsUpdate$);
};
</code></pre>
<p>-&gt; <a href="http://staltz.github.io/xstream/#merge">Docs on <code>xs.merge</code></a></p>
<p>One important aspect here is the <em>cyclical</em> aspect of our app architecture. Notice how the state
stream is constantly giving us new state as elements in the stream. Our <code>app</code> function is merely a
transformer along the way, returning state updates as sinks and receives the new state as source:</p>
<pre><code>------a---ax---ax------
  app() # Transforms the source stream
------ax--ax---axy-----
</code></pre>
<p>Once you‚Äôre used to ‚Äúthinking in cycles‚Äù, it creates quite a nice way of programming even complex
apps, since the pattern is very scalable. You‚Äôll be thinking in ‚Äúinputs and outputs‚Äù, and solely how
you will transform the inputs to a given output.</p>
<p>But derived state ain‚Äôt no fun. In a real app, we‚Äôve got lots of inputs! Mouse clicks from the user,
async calls coming back from web APIs‚Äâ‚Äî‚Äâa myriad of things that should update our state. Let‚Äôs
investigate the former!</p>
<h2>Sending -&gt; Messages</h2>
<p>Any app must deal with user input. Button clicks, text fields, forms, and so on. As our app
architecture looks so far, there‚Äôs only derived state updates. Meaning, we only transform the state
we have already.</p>
<p><strong>We need to construct a way to let the view pass messages to our app function.</strong></p>
<p>We haven‚Äôt looked at the view yet, but remember it‚Äôs <strong>outside</strong> our pure, cozy, functional world
inside of our app function. In the app function, we solely deal with functional streams which we
apply <code>map</code>, <code>filter</code> and other operations on.</p>
<p>When I say <em>messages</em>, I refer to something like <em>signals</em> or <em>events</em> that are emitted from the UI
element the user interacted with. We need two things in these messages:</p>
<ol>
<li>An identifier in order to distinguish between different kinds of messages.</li>
<li>An optional payload with data attached to the message.</li>
</ol>
<p>Let‚Äôs see how we can get those messages into our app function!</p>
<p>We‚Äôve modelled data as streams so far, so why not continue on that track. Imagine a <code>view$</code> stream
which is a stream of <em>all</em> different kinds of messages‚Äâ‚Äî‚Äâuser input‚Äâ‚Äî‚Äâcoming from the view.</p>
<p>I imagine this flow being something like this:</p>
<figure id="view-model">
  <img width="413" alt="Messages flow" src="/assets/posts/frap-messages.png">
  <figcaption>Simplified flow diagram.</figcaption>
</figure>
<p>How does a message look like then? Perhaps like this:</p>
<pre><code class="language-typescript">interface ToggleModal {
	kind: 'toggle_modal';
	modalName: 'surveyModal' | 'loginModal';
	open: boolean;
}

interface SetPerson {
	kind: 'set_person';
	person: {
		name: string;
		age: number;
	};
}

type ViewMsg = ToggleModal | SetPerson;
</code></pre>
<p>These resemble ‚Äúactions‚Äù you would send to a reducer when using the Flux architecture.</p>
<p>The last <code>ViewMsg</code> type forms the union type which our messages stream consists of:
<code>Stream&lt;ViewMsg&gt;</code>. Let‚Äôs investigate how this fits into our app architecture.</p>
<p>We‚Äôve got our <code>app</code> function which produces state updates and receives state from <code>run</code>. The latter
can be modified to accept a stream of view messages:</p>
<pre><code class="language-typescript">import xs from 'xstream';

const run = &lt;ViewMsg&gt;(
	main: Main,
	view$: Stream&lt;ViewMsg&gt;,
	startState: State,
) =&gt; {
	const fakeUpdates$ = xs.create();

	const state$ = stateUpdate$.fold(
		(prev, update) =&gt; ({ ...prev, ...update }),
		startState,
	);

	const appUpdate$ = main(state$, view$);

	fakeUpdates$.imitate(appUpdate$);

	return state$;
};
</code></pre>
<p>I‚Äôve introduced a generic type <code>ViewMsg</code> in the <code>run</code> function. Let‚Äôs start our app:</p>
<pre><code class="language-typescript">// run :: (Main, Stream&lt;V&gt;, State) -&gt; Stream&lt;State&gt;
import { run } from 'frap';

export interface State {
	name: string;
}

export const startState: State = {
	name: 'Johan',
};

interface SetName {
	kind: 'set_name';
	name: string;
}

export type ViewMsg = SetName;

const app: Main = (state$: Stream&lt;State&gt;, view$: Stream&lt;ViewMsg&gt;) =&gt; {
	const stateUpdate$ = view$
		// Only filter on the `SetName` type of messages
		.filter((m): m is SetName =&gt; !!m.kind &amp;&amp; m.kind === 'set_name')
		// Set a new name by mapping the payload from the message to a state update
		.map((m) =&gt; ({
			name: m.name,
		}));

	return xs.merge(stateUpdate$);
};

// TODO Build view and construct messages stream
const view$ = xs.create&lt;ViewMsg&gt;();

// Kick it off! üöÄ
run(app, view$, startState);
</code></pre>
<p>Now, <em>imagine</em> that the <code>view$</code> stream is working. Imagine that for every time a user is submitting
a form text field with some text, the view will construct the <code>SetName</code> message object and put it on
the view stream. This view stream can flow through our app‚Äôs business logic as a regular function
parameter, and we can <code>filter</code> to get specific messages and then <code>map</code> them to do state updates.</p>
<p>This makes the separation between view and business logic pretty clear‚Äâ‚Äî‚Äâwhich is a good thing! We
can test our app in isolation by feeding mocked messages into the view stream and asserting the
resulting state without having to mount the view. The view‚Äôs actions don‚Äôt have to be side effects,
as it‚Äôs often regarded to be in other app setups.</p>
<hr>
<p>So far, we‚Äôve stayed inside or pure, functional domain of streams. The next section will go through
the elephant in the room.</p>
<h2>A View to a <s>kill</s> Stream</h2>
<p>We begin with this simple but beautiful idea:</p>
<blockquote>
<p>ui = view(state)</p>
</blockquote>
<p><em>The View is a function of state, producing User Interface.</em></p>
<p>This idea isn‚Äôt new of course: it exists in various shapes and philosophies, such as MVC, MVVM, MVI,
and so on. The concept of having a view that listens to state is a baseline in many design patterns.</p>
<p><strong>Q:</strong> But how do we do this in Frap? Where we have a single stream of state?</p>
<p><strong>A:</strong> We rely on a virtual DOM!</p>
<p>This means, we re-render our whole component tree on each new state update. This feels terribly
expensive and weird, but we must simply rely on that our virtual DOM implementation will calculate
the smallest diff in the real DOM and apply that. The whole design idea behind React is built on
this principle: to rely on the virtual DOM.</p>
<p>As you saw above in the code samples at the top, UI components in CycleJS use streams as first class
citizens. The components are really just functions which accepts input streams and return output
streams. A common lingo in the streams world is <em>Sources</em> and <em>Sinks</em> to signify the input and
outputs. Thanks to this property of CycleJS, components can receive a stream of values (‚Äúprops‚Äù in
React world) and return a stream of virtual DOM nodes and a stream of new values, emitted from the
component. React works differently. React components <em>must</em> return JSX (or a virtual DOM node,
however you choose to write it). So we just can‚Äôt make React components return a stream of JSX and
expect things to work, of course.</p>
<p>Have a look at the <a href="#view-model">view figure</a> again. We see that the view should accept a
state stream and ‚Äúreturn‚Äù a messages stream (I say ‚Äúreturn‚Äù within quotes since it‚Äôs not really
gonna return the stream).</p>
<p>But how do we draw a whole React app from a stream? We can‚Äôt return a stream of virtual DOM nodes
here?</p>
<p><strong>We must open up the state stream somehow and let it drive the rendering of the top level
component.</strong></p>
<p>(This means the React app will re-render on each state update. <em>Again, this is fine</em>. Does the app
feel slow? Profile with React‚Äôs dev tools, as
<a href="https://twitter.com/ryanflorence/status/1126734015950536706">this tweet</a> advises).</p>
<p>In most stream libraries, there‚Äôs a method called <code>subscribe</code> which you can use on a stream. In
xstream, it adds a listener on a stream and returns a subscription that can be used to remove that
listener (read the <a href="http://staltz.github.io/xstream/#subscribe">docs</a>). We can use that to subscribe
to state updates, and then unsubscribe when our app unmounts.</p>
<p>In the <code>next</code> callback of <code>subscribe</code>, we‚Äôll receive each new element in the stream (we can also
catch errors in <code>error</code>). We use <code>next</code> to set the state of the React component at top level. From
then on, we‚Äôll let React figure out how to draw the DOM based on that very state. For each new state
update, <code>next</code> will be called, and React will re-render the tree. Incremental, immutable state.</p>
<p>Here‚Äôs the function signature of <code>run</code>:</p>
<pre><code class="language-typescript">type Run = (Main, view$: Stream&lt;ViewMsg&gt;, startState: State) =&gt; Stream&lt;State&gt;;
</code></pre>
<p>Before, we‚Äôve just called <code>run</code> for funsies without really thinking too much about where and how
we‚Äôll handle it‚Äôs output stream. I can reveal to you now that the function should ideally be called
when your top level React component mounts.</p>
<pre><code class="language-tsx">import React from 'react';
import { Stream, Subscription } from 'xstream';
import { run } from 'frap';

// Imported from our main file
import { app, startState, State, ViewMsg } from './main.ts';

/** The state of our React component */
interface AppState {
	state$: Stream&lt;State&gt;;
	/** This holds our "real" app state ‚Äì ready to render! */
	appState: State;
}

type Send = (event: ViewMsg) =&gt; void;

class App extends React.Component&lt;any, AppState&gt; {
	/** Instance variable holding the subscription to the state stream. */
	sub: Subscription;

	/** Instance function used to drive messages into the view stream. */
	send: Send | null = null;

	constructor(props) {
		super(props);

		// Stream of input from the views.
		const view$ = xs.create&lt;ViewMsg&gt;();

		// Create our "send" function which will drive messages on to
		// the view stream above.
		this.send = (v: ViewMsg) =&gt; {
			view$.shamefullySendNext(v);
		};

		// Kick everything off! üöÄ
		const state$ = run(app, view$, startState);

		// Attach on component's local state so we an access it
		// in life cycle methods
		this.state = {
			state$,
			appState: startState,
		};
	}

	componentDidMount(): void {
		// Start subscribing to incoming state and set the local
		// state of our React component. Will trigger re-render.
		this.sub = this.state.state$.subscribe({
			next: (appState) =&gt; {
				this.setState({ appState });
			},
			error: (err) =&gt; {
				console.error(err);
			},
		});
	}

	componentWillUnmount(): void {
		// Unsubscribe from state subscription:
		this.sub.unsubscribe();
	}

	render(): React.ReactNode {
		const { appState } = this.state;

		// Render the 'name' state and a button to change it.
		return (
			&lt;div&gt;
				&lt;h1&gt;Hi {appState.name}!&lt;/h1&gt;

				&lt;button
					onClick={() =&gt;
						this.send({
							kind: 'set_name',
							name: 'Johnny Doe',
						})}
				&gt;
					Set another name
				&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre>
<p>(The class approach is a bit verbose, but React Hooks is still a new concept which is outside the
scope of this post. Here‚Äôs a
<a href="https://gist.github.com/brookback/d98efdfb4a3087dbba767910f2eec2f3">GitHub Gist</a> including a Hooks
version).</p>
<p>Notice how we:</p>
<ol>
<li>Create a <code>view$</code> stream in the constructor and pass it to <code>run</code>.</li>
<li>Create a <code>send</code> function on the app component which can be used from view event handlers to send
messages.</li>
<li>Subscribe to state updates when mounted.</li>
<li>Render the state in <code>render()</code>.</li>
</ol>
<p>The main fishy thing here might be the <code>shamefullySendNext</code> method in <code>send</code>. As from the
<a href="http://staltz.github.io/xstream/#shamefullySendNext">docs</a>, this method forces a new value to be
emitted to the stream. This is the one of the two ‚Äúbridges‚Äù between our functional app world and the
imperative view (the <code>subscribe()</code> call being the other one).</p>
<p>Phew. Lots of code and concepts. In this section, we‚Äôve:</p>
<ul>
<li>seen how to add the view layer (here React) to our app architecture.</li>
<li>how to pass actual messages from the view.</li>
<li>render a React component from our state.</li>
</ul>
<p>There‚Äôs one thing missing still. Where are all the async API calls, browser API functions, and
logging utilities?</p>
<p>Yes: where are the <em>side effects</em>?</p>
<h2>Side effects üíÄ</h2>
<p>In any non-trivial application, there <em>will</em> be side effects. Side effects in this case refer to
things similar to:</p>
<ul>
<li>Fetching JSON from an API server</li>
<li>Using Chrome‚Äôs media APIs to gain access to the web camera</li>
</ul>
<p>The common denominator is that drivers include <em>imperative code</em>. Code that isn‚Äôt functional
streams. Code that affect the outside world. Code that is non-pure.</p>
<p>I recommend reading the <em>Drivers</em> section on <a href="https://cycle.js.org/drivers.html">CycleJS‚Äôs page</a>,
since we stole the concept of Drivers from there. There are many good examples there as well.</p>
<p>Once you‚Äôve done that, return back here.</p>
<hr>
<p>We‚Äôre gonna use the exact same concept of drivers in Frap. Drivers receive <em>Sinks</em> and return
<em>Sources</em>. This is in contrast to our main app function, which receives <em>Sources</em> and returns
<em>Sinks</em>.</p>
<p>The flow diagram thus becomes:</p>
<figure id="view-model">
  <img width="624" alt="Driver flow" src="/assets/posts/frap-driver-flow.png">
  <figcaption>App architecture with drivers and view.</figcaption>
</figure>
<p>Let‚Äôs nail down our Sources and Sinks here.</p>
<ul>
<li><strong>To our <code>app</code> function,</strong> Sources are all input sources it needs to do its job. View messages,
driver input, the state stream. Sinks are output instructions to drivers and state updates.</li>
<li><strong>To the drivers,</strong> Sources are the output instructions (as a stream) from <code>app()</code>. Sinks can be
anything.</li>
</ul>
<p>The <code>run()</code> function from Frap takes care of glueing all of this together.</p>
<p>We communicate with the drivers with a single <em>out</em> stream with messages. A driver can thus look
like:</p>
<p><strong>Driver</strong></p>
<pre><code class="language-typescript">// ConsoleLogDriver.ts
import { Stream } from 'xstream';

interface DoLog {
	kind: 'do_log';
	label: string;
	args?: any[];
}

export type ConsoleOut = DoLog;

/** A logging driver that consumes log messages and
 * only performs writes to the console.
 */
const ConsoleLogDriver = (out$: Stream&lt;ConsoleOut&gt;) =&gt; {
	out$.filter((m): m is DoLog =&gt; !!m.kind &amp;&amp; m.kind === 'do_log').addListener(
		(m) =&gt; console.log(m.label, ...m.args),
	);
};

export default ConsoleLogDriver;
</code></pre>
<p>As you see, a driver is üåàJust A Function üåà.</p>
<p>This particular example of a driver only consumes sinks but doesn‚Äôt return any sources back to our
<code>app()</code> function.</p>
<p>How do we hook up this driver? We need to modify the <code>run</code> function!</p>
<p><strong>Run</strong></p>
<pre><code class="language-typescript">import xs from 'xstream';

interface Sources&lt;V&gt; {
  view$: Stream&lt;V&gt;;
  drivers?: {
    [key: string]: (s: Stream&lt;any&gt;) =&gt; void | Stream&lt;any&gt;;
  };
}

const run = &lt;V&gt;(main: Main, sources: Sources, startState: State) =&gt; {
  const { view$, drivers } = sources;

  const fakeUpdates$ = xs.create();
  const fakeDriverOuts = createFakeDriverOut(drivers);

  const state$ = stateUpdate$.fold((prev, update) =&gt;
    ({ ...prev, ...update }), startState);

  // The sources to our app: state, messages, and driver input
  const mainSources = {
    state$,
    view$,
    ...callDrivers(drivers, fakeDriverOuts),
  }

  const { stateUpdate$, ...driverSinks } = main(mainSources);

  fakeUpdates$.imitate(stateUpdate$);

  for (const name in fakeDriverOuts) {
    const fake$ = fakeDriverOuts[name];
    const driverOut$ = driverSinks[name];

    fake$.imitate(driverOut$));
  }

  return state$;
};
</code></pre>
<p>This might look a bit hairy. I‚Äôve left out the implementation of two functions here:</p>
<ul>
<li><code>createFakeDriverOut</code>. Similarily to the state updates, we need to have a cyclic relationship
between the drivers‚Äô sinks and sources and the main app function. In this function, we create a
fake stream for each driver specified.</li>
<li><code>callDrivers</code>. We call all the driver functions with the fake outputs and feed the drivers‚Äô
returned output as sources to our main app function.</li>
</ul>
<p><strong>Main app</strong></p>
<pre><code class="language-typescript">// main.ts
import { run } from 'frap';
import { ConsoleOut } from './ConsoleLogDriver.ts';

export interface State {
  name: string;
}

export const startState: State = {
  name: 'Johan',
};

interface SetName {
  kind: 'set_name';
  name: string;
}

export type ViewMsg = SetName;

interface MainSources {
  view$: Stream&lt;ViewMsg&gt;;
  state$: Stream&lt;State&gt;;
}

interface MainSinks {
  stateUpdate$: Stream&lt;Partial&lt;State&gt;&gt;;
  console: Stream&lt;ConsoleOut&gt;;
}

const app: Main = (sources: MainSources): MainSinks =&gt; {

  // Access driver sources with:
  //   sources.myDriver.*

  const stateUpdate$ = /* updates to state */;

  // Send log message to log driver every second:
  const logDriverOut$ = xs
    .periodic(1000)
    .mapTo({
      kind: 'do_log',
      label: 'Hello!',
    }):

  // Return sinks
  return {
    // State updates as usual
    stateUpdate$,
    // Output instructions to the console driver. The key
    // needs to match the name of the driver specified in
    // the `drivers` argument to `run` below.
    console: logDriverOut$,
  };
};
</code></pre>
<p><strong>View</strong></p>
<pre><code class="language-typescript">import ConsoleLogDriver from './ConsoleLogDriver.ts';

// In the react view, run our app:
run(
	app,
	{
		view$,
		drivers: {
			// ... with the console log driver function
			console: ConsoleLogDriver,
		},
	},
	startState,
);
</code></pre>
<hr>
<p>That‚Äôs it! Now we can handle all side effects in their special drivers, where they can do all kinds
of reads and writes with the external world, and safely pass back their results as sources (‚Äúinput‚Äù)
to our app.</p>
<h2>Parting words</h2>
<p>What I love about this architecture we‚Äôve just built are these things:</p>
<ul>
<li>Reasoning in reactive streams! üòç Forget about mutability and writing imperative code. Say hello to
declarative code and ‚Äútight‚Äù business logic.</li>
<li>How well it goes along with React‚Äôs virtual DOM nature.</li>
<li>How the architecture is flexible enough to allow for all varieties of organising your app, still
being strict with what types you pass around.</li>
<li>How well it scales. Almost every new feature you‚Äôll add to your app will be written in the same
style.</li>
<li>How safe I feel when everything from the library layer (Frap) to the view layer (React) is handled
with a type system (Typescript).</li>
</ul>
<p>Here‚Äôs the complete library code:</p>
<p class="tc">
  <a href="https://github.com/lookback/frap" class="btn">lookback/frap</a>
</p>
<p>A huge shoutout to the creators of CycleJS. We‚Äôve been inspired by them in just about everything.
Thanks for popularising the ideas of cyclical data flows!</p>
<p class="tc">
  <strong>Thank you so much for reading ‚ú®</strong>
</p>

    </div>
  </article>
</main>


			<footer role="contentinfo">
  <nav>
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/feed.xml" title="Atom">Post feed</a></li>
        <li><a href="/micro.xml" title="Atom">Micro feed</a></li>
        <li><a href="/reading.xml" title="Atom">Reading feed</a></li>
    </ul>
  </nav>
</footer>

		</div>

		
	   		<nav role="navigation" class="MainNav">
	<div class="sticky">
		<h1 class="f4 sr-only-mobile">
			<a href="/" aria-label="Home">
				<span>Johan Brook</span><span aria-hidden="true" class="BackLink ml2">‚Üê</span>
			</a>
		</h1>

		<ul>
           	<li class="only-mobile">
          		<a href="/">Home</a>
           	</li>
          		<li>
         			<a href="/now/">Now</a>
          		</li>
          		<li>
         			<a href="/mind/">Micro</a>
          		</li>
          		<li>
         			<a href="/about/">About</a>
          		</li>
          		<li>
         			<a href="/reading/">Reading</a>
          		</li>
          		<li>
         			<a href="/writings/">Writings</a>
          		</li>
          		<li>
         			<a href="/all/">All pages</a>
          		</li>
        </ul>
	</div>
</nav>

	 	
	  </div>

      <script>
  // Only load on production environment.
  if (window.location.host !== new URL('https://johan.im').host) {
    window.goatcounter = {no_onload: true};
  }

  // Skip own views
  if (window.location.hash === '#skipgc')
    localStorage.setItem('skipgc', 't');
  if (localStorage.getItem('skipgc') === 't')
    window.goatcounter = {no_onload: true};
</script>
<script data-goatcounter="https://johanbrook.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>

  


</body></html>