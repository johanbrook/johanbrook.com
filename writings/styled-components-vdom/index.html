<!DOCTYPE html>
<html lang="en-gb" class=" writingsstyled-components-vdom"><head itemtype="http://schema.org/Blog" itemscope="">
    <title>Styled components in a virtual DOM / Johan</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://gc.zgo.at">
    <link rel="preconnect" href="https://johanbrook.goatcounter.com">

    <meta name="generator" content="Lume">

    
    <meta name="description" content="Learn how to create re-usable styled components in a virtual DOM. This post describes how one can use functional CSS (small, atomical classes) together with a higher order component and create pre-styled components.">
    
    
    <meta name="keywords" content="cyclejs,virtual dom,typescript,components,css,styled components,functional css">
    
    <meta name="author" content="Johan Brook">

    <!-- Styles-->
    
        <link rel="stylesheet" href="/johan.css">
    

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Posts feed (RSS)" href="/writings.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Posts feed (JSON)" href="/writings.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Micro feed (RSS)" href="/micro.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Micro feed (JSON)" href="/micro.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Book feed (RSS)" href="/reading.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Book feed (JSON)" href="/reading.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Recipes feed (RSS)" href="/recipes.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Recipes feed (JSON)" href="/recipes.json">

    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <link rel="canonical" itemprop="url" href="https://johan.im/writings/styled-components-vdom/">
    <link rel="author" href="https://johan.im">
    <link rel="me" href="https://hachyderm.io/@brookie">

    <meta property="og:title" content="Styled components in a virtual DOM">
    <meta property="og:url" content="https://johan.im/writings/styled-components-vdom/">
    <meta property="og:site_name" itemprop="name" content="Johan Brook">
    
    <meta property="og:locale" content="en_GB">
    
    <meta property="og:description" content="Learn how to create re-usable styled components in a virtual DOM. This post describes how one can use functional CSS (small, atomical classes) together with a higher order component and create pre-styled components.">
    

    

    
	<meta property="og:type" content="article">
    <meta property="article:tag" content="cyclejs,virtual dom,typescript,components,css,styled components,functional css">
    <meta property="article:published_time" content="2018-09-09T02:00:00+02:00">
   	
  </head>

  <body>
  	  <a href="#main" class="visually-hidden skip-link">Skip to content</a>

     

	  <div class="Content">

		

<nav role="navigation" class="MobileNav">
    <p class="mb0">
        <a aria-label="Home" class="MobileNav__Home plain" href="/">Johan</a> <span class="faint">/</span> <a href="/writings" class="muted">Writings</a>
    </p>
    <div class="relative">
        <details>
            <summary>Menu</summary>
            <ul role="list" class="NavList">
              		<li>
             			<a href="/micro/">Micro</a>
              		</li>
              		<li>
             			<a href="/now/">Now</a>
              		</li>
              		<li>
             			<a href="/reading/">Reading</a>
              		</li>
              		<li>
             			<a href="/about/">About</a>
              		</li>
              		<li aria-current="page">
             			<a href="/writings/">Writings</a>
              		</li>
              		<li>
             			<a href="/recipes/">Recipes</a>
              		</li>
              		<li>
             			<a href="/feeds/">Feeds</a>
              		</li>
                <li>
         			<a href="/all">All pages</a>
          		</li>
            </ul>
        </details>
    </div>
</nav>


		<div id="main">
			<main role="main">
  <article class="Post" role="article" itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 itemprop="name" class="title">Styled components in a virtual DOM</h1>

      <p class="mb0 fw5">
          <time class="text-color-contrast" datetime="2018-09-09T02:00:00+02:00" title="Sunday, 9 September 2018 at 02:00:00 Central European Time" itemprop="datePublished" pubdate="">
            September 9, 2018
          </time>
          
          
      </p>

      <p class="f5 mb4 font-sans muted">
          About 6 min reading time
      </p>
    </header>

    <div class="prose" itemprop="articleBody">
      
      <p><strong>At Lookback, we’ve recently tried out using CycleJS</strong> for a web client code base. <a href="https://github.com/cyclejs/cyclejs">CycleJS</a> is
all about <em>cyclic reactive functional streams</em> and promises nice separation of concerns by
separating out side effects and handling of external APIs into something called <em>Drivers</em>. It uses a
virtual DOM, like React, to translate app state to user interface. Add a dash of TypeScript, and
you’ve got a really nice and tight web frontend setup.</p>
<p>My interest for both frontend architecture and design systems made me see an opportunity to create
styled components for for re-use in the virtual DOM. The idea is to construct small, re-usable
components to use instead of marking up content with the regular approach of using CSS classes. The
key in our approach here isn’t inline CSS embedded on the component, but about applying <em>functional
CSS</em> classes.</p>
<p>I once held a pretty strong opinion that one should separate markup and styling of a web page. That
works out pretty good for web content with document style content — just like all the early web
pages were. When building complex information architectures in ever changing web apps, where the
cascading part of CSS just gets in your way, I’ve turned to investigate this functional CSS class
approach instead. There’s writing on this philosophy elsewhere:</p>
<ul>
<li><a href="https://jon.gold/2015/07/functional-css/">“Functional CSS”</a> by Jon Gold. Acts as a nice intro.</li>
<li><a href="https://adamwathan.me/css-utility-classes-and-separation-of-concerns/">“CSS Utility Classes and Separation Of Concerns”</a> by Adam Wathan. Gives real world problem
scenarios.</li>
</ul>
<p>Be sure to check out the <a href="https://tachyons.io/">Tachyons CSS library</a> (I’ve based Lookback’s internal functional CSS
library off Tachyons’ structure).</p>
<h2>A primer on functional CSS</h2>
<p>Let’s say we’ve got these CSS rules:</p>
<pre><code class="language-scss">// headings.scss

h1 {
  margin-bottom: $spacing-base;
}

// modals.scss

.modal {
  h1 {
    margin-bottom: $spacing-base / 3;
  }

  form {
    text-align: center;
  }
}
</code></pre>
<p>And here we’ve got the markup for modal content (here the scenario of creating a new project inside
of a generic web app):</p>
<pre><code class="language-html">&lt;div class="modal"&gt;
  &lt;h1&gt;New Project&lt;/h1&gt;

  &lt;form&gt;
    &lt;input name="project-name" placeholder="Project name"&gt;
    &lt;input type="submit" value="Create"&gt;
  &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>This will make all H1 headings in all modals have tighter bottom margin, and make all forms in all
modals have centered content. This is probably fine to start off with. But what if I’d like to have
more margin on a H1 heading in one certain modal?</p>
<p>I’d either:</p>
<ol>
<li>Introduce another namespace on that modal, perhaps <code>.modal-some-name</code> and apply more margin on
all <code>h1</code> elements in that namespace.</li>
<li>Introduce a new class name on those <code>h1</code> elements that need more margin, and apply it from CSS.</li>
</ol>
<p>Both of these solutions tightens the coupling between the markup and CSS, and forever creates a
dependency from the former on the latter. Meaning, during iterating on the product, I as a frontend
developer will be forced to go back and forth between the markup and CSS when requirements change,
features are added, and view hiearchies are refactored. In my experience, there’s <em>very few</em> changes
in the markup that also don’t require adjustments in the CSS — even for extremely well engineered
frontends.</p>
<p><strong>Enter functional CSS.</strong></p>
<p>Using functional CSS is to depart from the classical thought of <em>“No styling in the markup”</em>. We’re
not embedding inline styles <em>per se</em>, but we’re applying styling information that does not make any
semantic sense from a markup perspective.</p>
<p>This is the above example refactored to use functional CSS classes:</p>
<pre><code class="language-scss">// headings.scss

h1 {
  margin-bottom: $spacing-base;
}

// spacing.scss

.mb0 {
  margin-bottom: 0;
}

.mb1 {
  margin-bottom: $spacing-small;
}

// ...

// text-align.scss

.tc {
  text-align: center;
}
.tl {
  text-align: left;
}
.tr {
  text-align: right;
}
</code></pre>
<pre><code class="language-html">&lt;div class="modal"&gt;
  &lt;h1 class="mb0"&gt;New Project&lt;/h1&gt;

  &lt;form class="tl"&gt;
    ...
  &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>Note how the classes form a sort of domain specific language in describing which style rule or rules
that are applied. With functional CSS, I’m free to combine styles on elements by composition, as
well as deviate from common styling wherever I need to. I can use a <code>.f1</code> class to denote the
largest font size, and bind it to a Sass variable:</p>
<pre><code class="language-scss">// typography.scss
.f1 {
  font-size: $font-size-1;
}
</code></pre>
<p>So if I need to change font sizes all over the the web app, it’s still easy since we haven’t
embedded any inline CSS — just engineering everything with classes and variables.</p>
<h2>Components with functional CSS in a virtual DOM</h2>
<p>Back to the components part. During the development of said web client, I identified common patterns
from the design mockups. It could be a certain style for a form label or heading. They were present
frequently enough that warranted some kind of Don’t Repeat Yourself strategy, but still not
important enough for custom rules in the stylesheet.</p>
<p>Two aspects in this setup are quite crucial:</p>
<ol>
<li>Thanks to a very important part of functional CSS — <em>composition</em> — we can put together several
styles into one, without having the need to create a new CSS component for it.</li>
<li>The programmatic nature of virtual DOMs. Markup in the virtual DOMs of React and CycleJS are
really just function calls, with the signature <code>(selector, props, children)</code>.</li>
</ol>
<p>Let’s talk more about each one real quick:</p>
<h3>Composition</h3>
<p>Thanks to minimal functional CSS classes, we can do things like this:</p>
<pre><code class="language-html">&lt;label class=".f7.tracked.c-muted.mb1.b"&gt;Foo&lt;/label&gt;
</code></pre>
<p>This kind of cryptic class name string translates to:</p>
<ul>
<li><code>f7</code>- Font size of level 7 (smallest)</li>
<li><code>tracked</code>- Smallest letter spacing</li>
<li><code>c-muted</code>- Muted colour</li>
<li><code>mb1</code>- Bottom margin of level 1</li>
<li><code>b</code>- Bold font weight</li>
</ul>
<p>All these properties together make up a re-usable style stack.</p>
<h3>Markup as functions</h3>
<p>The virtual DOM in CycleJS is called <a href="https://github.com/snabbdom/snabbdom">Snabbdom</a>. In CycleJS, it looks like this:</p>
<pre><code class="language-typescript">import { div, h1, p, strong } from '@cycle/dom';

/*
This becomes:

  &lt;div&gt;
    &lt;h1 id="myId" class="my-heading some-other-class"&gt;Hello world&lt;/h1&gt;
    &lt;p&gt;&lt;strong&gt;This is bolder text&lt;/strong&gt; followed by a regular text node.&lt;/p&gt;
  &lt;/div&gt;
*/
const vdom = div([
  h1('#myId.my-heading.some-other-class', 'Hello world'),
  p([
    strong('This is bolder text'),
    'followed by a regular text node.'
  ]);
]);
</code></pre>
<p>The <code>div</code>, <code>h1</code>, <code>p</code>, and <code>strong</code> functions are helpers from the DOM lib of CycleJS. They follow
the signature <code>(selector?, props?, children?)</code>. The <code>selector</code> parameter is a CSS style selector
string, which is used to apply IDs and class names.</p>
<p>This way of building user interfaces was tedious at first for a seasoned HTML coder, but after a
while, treating DOM elements like functions became fluid. Not being held back by some stupid
constraints of the templating library you’re using, you can use all your Javascript skills to
construct components.</p>
<h2>Reusable components</h2>
<p>I thought to myself, <em>“If styling with functional CSS is only about applying small, atomic classes,
and classes in Snabbdom is just a selector string, I could store the classes a strings somewhere and
just import them and use them in the VDOM”</em>.</p>
<h3>Take One</h3>
<p>This became my first iteration:</p>
<pre><code class="language-typescript">// styles.ts

// Keep shared styles in this dict.
export const Styles = {
    SmallFormLabel: '.f7.ttu.comp-blue-f.mb1',

    TopHeading: '.lh-title.mb4',
};
</code></pre>
<pre><code class="language-typescript">// SomeComponent.ts
import { form, h1, input, label } from '@cycle/dom';
import { Styles } from './styles';

export default function SomeComponent(props) {
    const vdom = form([
        h1(Styles.TopHeading, 'My Form'),
        label(Styles.SmallFormLabel, { for: 'name' }, 'Label'),
        input({ type: 'text', id: 'name', placeholder: 'Name' }),
    ]);

    return vdom;
}
</code></pre>
<p>This makes it possible to control the exact appearance of a <code>SmallFormLabel</code> from within the
<code>styles.ts</code> file. Change there — change everywhere!</p>
<h3>Take Two</h3>
<p>This was quite fine, but still didn’t feel component-y enough. What about extensibility? If I wanted
to apply more styles to a <code>TopHeading</code>, I’d have to do an ES6 style string literal
<code>${Styles.TopHeading}.more-classes</code> and apply as selector. Not that elegant, and a lot to type.</p>
<p>Since VDOM elements are functions, we can implement a backing function which <em>enhances</em> a VDOM
element with a given selector, and returns the element ready to be used.</p>
<p>The signature would look like:</p>
<pre><code class="language-typescript">function enhanceWithStyle(domTag: DomTag, classes: Selector): DomTag;
</code></pre>
<p>where we’ve got the types:</p>
<pre><code class="language-typescript">type Selector = string;
// This is the signature for a Snabbdom helper, like h1(), p(), etc.
type DomTag = (sel?: Selector | any, ...args: any[]) =&gt; VNode;
</code></pre>
<p>Let’s enhance!</p>
<pre><code class="language-typescript">// styles.ts
import { h1, label } from '@cycle/dom';

const Styles = {
    SmallFormLabel: '.f7.ttu.comp-blue-f.mb1',

    TopHeading: '.lh-title.mb4',
};

export const SmallFormLabel = enhanceWithStyle(label, Styles.SmallFormLabel);

export const TopHeading = enhanceWithStyle(h1, Styles.TopHeading);
</code></pre>
<pre><code class="language-typescript">// SomeComponent.ts
import { form, input } from '@cycle/dom';
import { SmallFormLabel, TopHeading } from './styles';

export default function SomeComponent(props) {
    const vdom = form([
        TopHeading('.some-other-class', 'My Form'),
        SmallFormLabel({ for: 'name' }, 'Label'),
        input({ type: 'text', id: 'name', placeholder: 'Name' }),
    ]);

    return vdom;
}
</code></pre>
<p>Voíla! We can use our custom components just like any other, since it uses the signature
<code>(selector?, props?, children?)</code>. Composable and re-usable.</p>
<h3>Implementation</h3>
<p>The implementation for the enhance function is:</p>
<pre><code class="language-typescript">// styles.ts
import { VNode } from '@cycle/dom';

// specific type for selectors
export type Selector = string;

// This is the signature for a Snabbdom helper, which we need to also
// export if we use it ...
export type DomTag = (sel?: Selector | any, ...args: any[]) =&gt; VNode;

const isSelector = (str?: string): str is Selector =&gt;
    typeof str === 'string' &amp;&amp;
    str.length &gt; 1 &amp;&amp; // A selector with only a dot doesn't make sense. Require &gt; 1 chars
    str[0] === '.'; // Starts with a dot, like '.className'

export const concatSelectors = (...ss: Selector[]): Selector =&gt; ss.filter(isSelector).join('');

/**
 * Enhance an existing Snabbdom helper with a set of style classes,
 * in order to DRY things up.
 *
 * Example:
 *
 *    import { enhanceWithStyle } from './libs/styles';
 *
 *    // Enhance the label component from Snabbdom:
 *    const SmallLabel = enhanceWithStyle(label, '.some-class.another');
 *
 *    // Use in the DOM:
 *    SmallLabel('.more-classes', 'My Label');
 */
export const enhanceWithStyle = (domTag: DomTag, classes: Selector): DomTag =&gt;
(
    sel: any,
    ...args
) =&gt; {
    const tagArgsToPass = isSelector(sel)
        ? [
            // Apply our classes, and append any custom selector passed, if it's a string.
            concatSelectors(classes, sel),
            ...args,
        ]
        : [
            classes,
            sel, // sel isn't a selector here, treat it as an any argument to the Hyperscript helper
            ...args,
        ];

    return domTag(...tagArgsToPass);
};
</code></pre>
<h2>Conclusion</h2>
<p>What I like with this approach is the simplicity: many people understand the concept of composition.
I’m sure this kind of enhancement functions exist for React and other virtual DOMs, but this really
is something you can hack together on your own, since it’s “just” functions!</p>
<p>What we’ve achieved is:</p>
<ul>
<li><strong>Re-usability</strong> of styles in the shape of small VDOM helpers.</li>
<li><strong>Isolation</strong> of CSS styling into the <code>.css</code> file — not the app logic.</li>
<li><strong>Composition</strong> of style rules without having to deal with cascade headaches.</li>
</ul>
<p>Thanks for reading!</p>

    </div>
  </article>
</main>

		</div>

   		<nav role="navigation" class="MainNav">
	<div class="sticky">
		<h1 class="f4 font-sans">
			<a href="/" aria-label="Home">
				<span>Johan</span><span aria-hidden="true" class="BackLink ml2">←</span>
			</a>
		</h1>

		<ul role="list" class="NavList">
          		<li>
         			<a href="/micro/">Micro</a>
          		</li>
          		<li>
         			<a href="/now/">Now</a>
          		</li>
          		<li>
         			<a href="/reading/">Reading</a>
          		</li>
          		<li>
         			<a href="/about/">About</a>
          		</li>
          		<li aria-current="page">
         			<a href="/writings/">Writings</a>
          		</li>
          		<li>
         			<a href="/recipes/">Recipes</a>
          		</li>
          		<li>
         			<a href="/feeds/">Feeds</a>
          		</li>
            <li>
     			<a href="/all">All pages</a>
      		</li>
        </ul>
	</div>
</nav>

	  </div>

      <script>
  // Only load on production environment.
  if (window.location.host !== new URL('https://johan.im').host) {
    window.goatcounter = {no_onload: true};
  }

  // Skip own views
  if (window.location.hash === '#skipgc')
    localStorage.setItem('skipgc', 't');
  if (localStorage.getItem('skipgc') === 't')
    window.goatcounter = {no_onload: true};
</script>
<script data-goatcounter="https://johanbrook.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>

  


</body></html>