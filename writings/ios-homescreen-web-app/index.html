<!DOCTYPE html>
<html lang="en-gb" class=" writingsios-homescreen-web-app"><head itemtype="http://schema.org/Blog" itemscope="">
    <title>Customising an iOS home screen web app in 2021 / Johan</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="preconnect" href="https://gc.zgo.at">
    <link rel="preconnect" href="https://johanbrook.goatcounter.com">

    <meta name="generator" content="Lume">

    
    <meta name="description" content="Developing a mobile web app for iOS is tricky, since with new iOS releases, features are being added and removed, and new bugs appear. In this post, I walk through what worked for me and my simple app in iOS 15 (in 2021).">
    
    
    <meta name="author" content="Johan Brook">

    <!-- Styles-->
    
        <link rel="stylesheet" href="/johan.css">
    

    <!-- Feeds -->
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Posts feed (RSS)" href="/writings.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Posts feed (JSON)" href="/writings.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Micro feed (RSS)" href="/micro.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Micro feed (JSON)" href="/micro.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Book feed (RSS)" href="/reading.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Book feed (JSON)" href="/reading.json">
    <link rel="alternate" type="application/rss+xml" title="Johan Brook: Recipes feed (RSS)" href="/recipes.xml">
    <link rel="alternate" type="application/feed+json" title="Johan Brook: Recipes feed (JSON)" href="/recipes.json">

    <link rel="shortcut icon" href="/favicon.png" type="image/png">
    <link rel="canonical" itemprop="url" href="https://johan.im/writings/ios-homescreen-web-app/">
    <link rel="author" href="https://johan.im">
    <link rel="me" href="https://hachyderm.io/@brookie">

    <meta property="og:title" content="Customising an iOS home screen web app in 2021">
    <meta property="og:url" content="https://johan.im/writings/ios-homescreen-web-app/">
    <meta property="og:site_name" itemprop="name" content="Johan Brook">
    
    <meta property="og:locale" content="en_GB">
    
    <meta property="og:description" content="Developing a mobile web app for iOS is tricky, since with new iOS releases, features are being added and removed, and new bugs appear. In this post, I walk through what worked for me and my simple app in iOS 15 (in 2021).">
    

    

    
	<meta property="og:type" content="article">
    <meta property="article:tag" content="">
    <meta property="article:published_time" content="2021-12-14T01:00:00+01:00">
   	
  </head>

  <body>
  	  <a href="#main" class="visually-hidden skip-link">Skip to content</a>

     

	  <div class="Content">

		

<nav role="navigation" class="MobileNav">
    <p class="mb0">
        <a aria-label="Home" class="MobileNav__Home plain" href="/">Johan</a> <span class="faint">/</span> <a href="/writings" class="muted">Writings</a>
    </p>
    <div class="relative">
        <details>
            <summary>Menu</summary>
            <ul role="list" class="NavList">
              		<li>
             			<a href="/micro/">Micro</a>
              		</li>
              		<li>
             			<a href="/now/">Now</a>
              		</li>
              		<li>
             			<a href="/reading/">Reading</a>
              		</li>
              		<li>
             			<a href="/about/">About</a>
              		</li>
              		<li aria-current="page">
             			<a href="/writings/">Writings</a>
              		</li>
              		<li>
             			<a href="/recipes/">Recipes</a>
              		</li>
              		<li>
             			<a href="/feeds/">Feeds</a>
              		</li>
                <li>
         			<a href="/all">All pages</a>
          		</li>
            </ul>
        </details>
    </div>
</nav>


		<div id="main">
			<main role="main">
  <article class="Post" role="article" itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 itemprop="name" class="title">Customising an iOS home screen web app in 2021</h1>

      <p class="mb0 fw5">
          <time class="text-color-contrast" datetime="2021-12-14T01:00:00+01:00" title="Tuesday, 14 December 2021 at 01:00:00 Central European Time" itemprop="datePublished" pubdate="">
            December 14, 2021
          </time>
          
          
      </p>

      <p class="f5 mb4 font-sans muted">
          About 9 min reading time
      </p>
    </header>

    <div class="prose" itemprop="articleBody">
      
      <h2>Background</h2>
<p>During parental leave, I’ve started to run. Not away from the baby, for heaven’s sakes, but regular
exercise running. I really prioritised keeping it super straight-forward: I refuse wear any kind of
wearable, such an Apple Watch or Garmin in order to track heart rate and so on (I won’t go into why
here, I just don’t need another tech device). But. Even I see the need for tracking basic stats,
like duration, length of run, and average speed. Those are literally the three things I need.</p>
<p>Let’s see what running apps there are! <em>Opens up App Store.</em> “Strava, yes I’ve heard about that one.
Runkeeper… that one I’ve used before! ( = a lifetime ago)”. I installed Strava because it was at the
top, and hell begins. It prompts me for an account, which is fair enough I guess, but it still put
me off a bit. It’s also paid. Monthly subscription. And it shows nagging reminders to upgrade to a
paid plan <em>everywhere</em>. And it has social features, which I of course don’t need. It has so much
<em>stuff</em> I neither need nor want! As a developer on leave, the only sane thing to do is to write my
own running app.</p>
<p>Since I’m not a Swift or Objective-C developer (and have no intentions of becoming one), I need to
do it as a web app. Approximately 5 seconds after I decided to develop my own running tracker app I
realise I really must ensure that this single API is available in the iOS browser: being able to
<em>watch</em> the GPS position as it changes with the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API">Geolocation API</a>. Thank god,
<code>Geolocation.watchPosition()</code> exists, and a wave of relief is showering over me. That means I can
watch the position, stash away the raw coordinates, and do things with them. Such as converting to
<a href="https://geojson.org">GeoJSON</a> in order to calculate the length in kilometers and drawing the route
in an embedded map from Mapbox.</p>
<ul>
<li>You can try the final app here: <a href="https://runloop.pages.dev">runloop.pages.dev</a>. Be sure to add it
to your homescreen.</li>
<li>The source code for my app is over <a href="https://github.com/johanbrook/runloop">at GitHub</a>.</li>
</ul>
<h2>Apple documentation feels out of date</h2>
<p>I start out by going straight into the horse’s mouth: the Apple documentation on (mobile) Safari.
This should be the truth, and nothing but the truth! I head over to
<a href="https://developer.apple.com">developer.apple.com</a> and browse to some “Technologies” page where one
can input a “technology”. I put in
<a href="https://developer.apple.com/documentation/technologies?tags=Safari">“safari”</a>. The search results
only yield things that are interesting from a native app perspective, such as embedding web views.</p>
<p>Okay. I scroll around to the footer, and see
<a href="https://developer.apple.com/safari/">“Safari and the web”</a>. Score! These are the only interesting
links:</p>
<p><img src="/assets/posts/apple-docs-safari.png" alt="Apple docs"></p>
<p>Clicking that “More” link leads me to the
<a href="https://developer.apple.com/library/archive/navigation/index.html?filter=safari">“Documentation Archive”</a>.
That sounds nice. Latest change as of writing is in June 2018. Gulp.</p>
<p>Unless I’m missing something, there’s no official Apple documentation on iOS Safari. Except for
browsing through blog posts over at <a href="https://webkit.org">WebKit.org</a> and other release notes. Note
that I’m talking about proprietary Safari tech — not regular Web APIs you’d find over at MDN.</p>
<p>My next bet was simply googling around on problems as I encountered them.</p>
<h2>How to make a web app behave and look nicely on iOS 15 in 2021</h2>
<p>What follows is a stream of things I encountered while researching how to make a super slick iOS web
app in 2021. My phone is an iPhone 12 mini, and I’m using iOS 15.2 at the time of writing this post.</p>
<h3>Adding to home screen — don’t forget the icon</h3>
<p>I knew from before that adding a web page to the iOS home screen grants it special privileges. Like
not
<a href="https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/">wiping LocalStorage after just 7 days</a>.
Also, there’s the UX aspect, which is important: adding to the home screen removes the Safari chrome
(UI) and runs the web app in a frameless mode. This is nice.</p>
<p>This hasn’t changed since last time I looked, thank god. The option is still there in the Safari UI.
It’ll add use the <code>&lt;title&gt;</code> from your web page as the app title. You need to supply an icon yourself
(iOS will pick a fugly screenshot of your app otherwise).</p>
<p>Put this in your <code>&lt;head&gt;</code>:</p>
<pre><code class="language-html">&lt;link rel="apple-touch-icon" href="apple-touch-icon.png"&gt;
</code></pre>
<p>where the <code>href</code> attribute points to a PNG image with the icon file.</p>
<p>Refer to
<a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/app-icon/">Apple’s official guide on icons</a>
for sizes, since you can control which icon file that goes with which size, like this:</p>
<pre><code class="language-html">&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad.png"&gt;
</code></pre>
<h3>Viewport settings</h3>
<p>The single most important thing you’d want to do is to set the viewport width to the width of the
device. This is old school, but important:</p>
<pre><code class="language-html">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
</code></pre>
<p>If you feel like disabling the pinch-to-zoom behaviour of web pages, tack on an <code>user-scalable=no</code>:</p>
<pre><code class="language-html">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" /&gt;
</code></pre>
<p>For me, I wanted more native feel, so I disabled zoom. Even though it’s a bit user hostile. But the
user in this case is me, so I don’t care.</p>
<h3>Frameless mode and <code>manifest.json</code></h3>
<p>The next most important thing is to tell iOS that we’d like to run the web app in “frameless mode”,
or “without the browser chrome”. Otherwise your home screen web app icon only leads to a web page,
and thus merely becomes a shortcut. We want it to feel like an app!</p>
<pre><code class="language-html">&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
</code></pre>
<p>This still is the way to tell iOS to hide the address bar and all that.</p>
<p>But. When I clicked around on internal links in my app, I saw the browser chrome appear for every
link click! It would suck if Apple had crippled mobile web apps in this way, but I wasn’t too
surprised after all — this is Apple.</p>
<p>I started reading about
<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">“Web app manifests”</a>. Those manifests is a
JSON file which tells the browser more things when it runs the app in “PWA” (Progressive Web App)
mode. I’s mainly about customising presentation, such as titles, icons, splash screens, etc. So I
sort of wrote it off at first, and also thought Apple wouldn’t care about these kinds of valiant
efforts by the web community.</p>
<p>But I was wrong. I stuck a simple <code>manifest.json</code> in my root directory and linked it from my HTML:</p>
<pre><code class="language-html">&lt;link rel="manifest" href="/manifest.json" /&gt;
</code></pre>
<pre><code class="language-json">{
    "name": "Runloop",
    "scope": "/",
    "display": "standalone"
}
</code></pre>
<p>I’m not sure whether it was the <code>scope</code> or <code>display</code> parameter that made the internal links work
without chrome again, but this did the trick! iOS Safari <em>is</em> parsing this file after all. And I
have no idea why the <code>apple-mobile-web-app-capable</code> tag won’t cut it, but oh well. This feels like
an extra guard to <em>really</em> tell the system that my app is running standalone without any browser
chrome (“please”).</p>
<h3>Using the whole screen on iPhone models with notches</h3>
<p>My iPhone 12 mini has a notch, and is thus not a perfect rectangular display. We can tell the web
app to use the whole display with this:</p>
<pre><code class="language-html">&lt;meta name='viewport' content='initial-scale=1, viewport-fit=cover' /&gt;
</code></pre>
<p>That is, adding <code>viewport-fit=cover</code> to the <code>viewport</code> meta tag. Otherwise, Safari will play it safe
and make sure your app lives within a rectangular area far away from the notch.</p>
<p>Apple is kind and provides tech for us in order to avoid colliding with the notch and the virtual
home button at the bottom of the iPhone screen.
<a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/">I recommend reading this article</a>.</p>
<p>Basically, we’ve got four <code>env()</code> values to use:</p>
<pre><code class="language-css">env(safe-area-inset-top)
env(safe-area-inset-bottom)
env(safe-area-inset-left)
env(safe-area-inset-right)
</code></pre>
<p><code>env()</code> works where <code>var()</code> works — even inside <code>calc()</code>, which is nice. For instance, this is the
styling for my bottom <code>NavBar</code> component:</p>
<pre><code class="language-css">.NavBar {
  padding: var(--inset);
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
  padding-left: max(env(safe-area-inset-left), var(--inset));
  padding-right: max(env(safe-area-inset-right), var(--inset));
}
</code></pre>
<p><code>--inset</code> is set on <code>:root</code>, and is the “global padding” in my app. As you can see, I use it with
the <code>max()</code> function to make the left and right padding be whatever’s the max value of the safe area
and my inset.</p>
<h3>Styling taps on links and buttons</h3>
<p>Since the arrival of the first iOS (“iPhone OS”?), it’s been tricky to style taps on interactive
elements. Such as a different background on a button when you tap it. <code>:active</code> and <code>:hover</code> pseudo
selectors are both weird and strangely enough don’t manage to produce that native feel.</p>
<p>In 2021, turns your all you have to is adding a single no-op touch listener, and then you can use
<code>:active</code> as it’s intended to:</p>
<pre><code class="language-js">// Adding an empty touch listener will make :active CSS pseudo selector
// work in order to style taps on elements. Joy.
document.addEventListener('touchstart', (evt) =&gt; {});
</code></pre>
<p>Insert that snippet somewhere in your JS, and off you go.</p>
<h3>Making the app be 100% height and don’t show scrollbars</h3>
<p>You thought this was the kind of stuff you’d stop put up with in 2021? Think again. <code>100vh</code> won’t do
what you think it does, and Apple devs think it works “as intended”.
<a href="https://chanind.github.io/javascript/2019/09/28/avoid-100vh-on-mobile-web.html">Read more here</a> for
a demonstration. I almost can’t muster strength to explain it all, but the gist of it is that the
browser chrome in mobile Safari is dynamic in height and take up space. This affects the <code>vh</code> unit
and produces overflow.</p>
<p><a href="https://www.bram.us/2021/07/08/the-large-small-and-dynamic-viewports/">Dynamic viewports</a> will fix
this. But until then, I went with a boring Javascript fix:</p>
<pre><code class="language-ts">let lastHeight: number | null = null;

const setAppHeight = debounce(() =&gt; {
    const doc = document.documentElement;
    const height = window.innerHeight;

    if (height != lastHeight) {
        doc.style.setProperty('--app-height', `${height - MAGIC_NUMBER}px`);
        lastHeight = height;
    }
}, 100);

// This is the magic offset which one can subtract in order to hide scrollbars
// AT LEAST ON MY PHONE. YMMV.
const MAGIC_NUMBER = 3;

/** This is solving the STILL outstanding problem of using
 * height: 100vh on Mobile Safari. The problem is outlined here:
 * https://chanind.github.io/javascript/2019/09/28/avoid-100vh-on-mobile-web.html
 *
 * Instead, we control the height of a CSS variable which is mirroring
 * the window.innerHeight property.
 */
const fixMobileHeight = () =&gt; {
    window.addEventListener('resize', setAppHeight);

    setAppHeight();

    return () =&gt; window.removeEventListener('resize', setAppHeight);
};

// Util
const debounce = (func: (...args: unknown[]) =&gt; unknown, wait: number) =&gt; {
    let timeout: NodeJS.Timeout;

    return (...args: unknown[]) =&gt; {
        const later = () =&gt; {
            clearTimeout(timeout);
            func(...args);
        };

        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

fixMobileHeight();
</code></pre>
<pre><code class="language-css">#app {
  min-height: var(--app-height);
}
</code></pre>
<p>We use the <code>resize</code> event which fires on <code>window</code> to set a CSS variable, which we can use in our
stylesheet. It has some guards so that we won’t fire it too often.</p>
<h3>Dark mode</h3>
<p>Don’t forget enabling dark mode so Safari can style native elements:</p>
<pre><code class="language-css">:root {
  color-scheme: light dark;
}
</code></pre>
<p>This is controllable from a tag within <code>&lt;head&gt;</code> too (which I guess is faster since the browser
doesn’t have to download and parse the CSS to decide).</p>
<h3>Theme colours</h3>
<p>This is new, and very marketed by Apple dev evangelists: the possibility to set the “theme colour”,
which makes Safari use a configured colour of your choice in the browser chrome. Safari is trying to
be smart, and defaults to the <code>background-color</code> on your <code>html</code> or <code>body</code> elements, but sometimes
you need to set it on your own:</p>
<pre><code class="language-html">&lt;meta name="theme-color" content="#fff" media="(prefers-color-scheme: light)" /&gt;
&lt;meta name="theme-color" content="#000" media="(prefers-color-scheme: dark)" /&gt;
</code></pre>
<h3>System colours</h3>
<p>Speaking of colours: dark mode isn’t cool, you know what’s cool? System colours (that joke fell…). I
stumbled upon this blog post:
<a href="https://blog.jim-nielsen.com/2021/css-system-colors/">“CSS System Colors”</a>. The author emphasised
not hard coding any colours for light and dark modes. Instead, he lets the system decide from
sensible defaults. For a website or app without need for any special branding, this is probably what
you want.</p>
<p>But what do you do when you actually want to <em>use</em> one of these system colours elsewhere in your
CSS? That’s the core question in the linked blog post, I’ll let you read it.</p>
<p><em>tldr</em>: there are “system colors” defined in the
<a href="https://drafts.csswg.org/css-color/#css-system-colors">CSS spec</a>, which you can use like any other
colour:</p>
<pre><code class="language-css">.dropdown {
  background-color: Canvas;
}
</code></pre>
<p>Of course, there’s a bug (?) in iOS, so <code>Canvas</code> backgrounds don’t work properly. The blog post
suggests using the <code>-apple-system-control-background</code> value as a hack, and it works. Copied from the
post:</p>
<pre><code class="language-css">/* Defaults/fallbacks for 1) */
:root {
  --color-bg: #fff;
  --color-text: #222;
}

/* 1) For browsers that don’t support `color-scheme` and therefore
   don't handle system dark mode for you automatically
   (Firefox), handle it for them. */
@supports not (color-scheme: light dark) {
  html {
    background: var(--color-bg);
    color: var(--color-text);
  }
}

/* 2) For browsers that support automatic dark/light mode
   As well as system colors, set those */
@supports (color-scheme: light dark) and (background-color: Canvas) and (color: CanvasText) {
  :root {
    --color-bg: Canvas;
    --color-text: CanvasText;
  }
}

/* 3) For Safari on iOS. Hacky, but it works. */
@supports (background-color: -apple-system-control-background) and (color: text) {
  :root {
    --color-bg: -apple-system-control-background;
    --color-text: text;
  }
}

html {
  background-color: var(--color-bg);
  color: var(--color-text);
}
</code></pre>
<p>This worked for me. Now I can use <code>--color-bg</code> wherever I want to use the (dynamic, non hard coded)
background colour.</p>
<h3>Disabling selecting text</h3>
<p>This also goes in the “user hostile” department. Use are your own discretion:</p>
<pre><code class="language-css">html {
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
}
</code></pre>
<h3>Use an iOS-y font stack</h3>
<p>I went with this, to get the SF font:</p>
<pre><code class="language-css">font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell',
        'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
</code></pre>
<h2>Conclusion</h2>
<p>After all these fixes, my app finally felt pretty good to use on an iPhone. It looked gorgeous in
dark mode, the typography was great, it felt snappy navigating around, and not like a wEbSiTe at
all.</p>
<p>I’m most impressed over how easy it is to make the <em>styling</em> look nice. Before iOS 7, when we were
in skeumorphism land, it was a pain to make web apps blend into the system. Now it’s just some
typography, spacing, and default colours, and we’ve come a long way. If you just “know” how a
typical iOS app looks like — with list views, headings and so on — I bet you’ll get something that
looks decent in no time thanks to the CSS snippets I’ve posted throughout the text.</p>
<p>I was most surprised over the show-chrome-on-link-tap thing in the home screen app. I had no idea
one needed to use a Webmanifest JSON file to get rid of that. I’ve found <em>very little</em> documentation
on iOS’ use of the web manifest file too.</p>
<h3>Nice Web APIs</h3>
<p>Overall, Web APIs have gone a long way with I/O: we can now upload, download, and <em>share</em> files in
iOS. I built and export and import feature to try this out, and it worked great on mobile:</p>
<pre><code class="language-ts">const doImport = async (evt: Event) =&gt; {
    const { files } = evt.target as HTMLInputElement;

    const file = files[0];

    if (file.type != 'application/json') {
        alert('Only JSON files, please.');
        return;
    }

    try {
        const json = JSON.parse(await file.text());
        // do stuff with object
    } catch (ex) {
        console.error(ex);
        alert(`Failed to read "${file.name}". Reason: ${ex}`);
    }
};

document.findElementById('import')!.addEventListener('change', doImport);
</code></pre>
<pre><code class="language-html">&lt;input type="file" id="import" accept="application/json" /&gt;
</code></pre>
<p>Exporting works good with the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share">Share API</a>:</p>
<pre><code class="language-ts">const doExport = async () =&gt; {
    try {
        // Will show native iOS share pane
        await navigator.share({
            title: 'Run data as JSON',
            files: [fileOf(appConf)],
        });
    } catch (ex) {
        if ((ex as DOMException).name == 'AbortError') return;
        alert(`Sharing failed. Reason: ${(ex as Error).message || ex}`);
        console.error(ex);
    }
};

const fileOf = (data: unknown): File =&gt;
    new File([JSON.stringify(appConf, null, 4)], 'runloop.json', {
        type: 'application/json',
    });
</code></pre>
<p>The user now gets the choice of saving the file somewhere, or sending it with the native UI
controls.</p>
<h2>Epilogue</h2>
<p>The irony is that my running tracker app didn’t work <em>at all</em> out in the wild… Turns out that the
system turns off any background geolocation services when the screen is locked — which totally is
the case when I’m running. And there’s no Geolocation in Service Workers or similar background magic
place. Argh.</p>
<p>See it in action here: <a href="https://runloop.pages.dev">runloop.pages.dev</a>.</p>

    </div>
  </article>
</main>

		</div>

   		<nav role="navigation" class="MainNav">
	<div class="sticky">
		<h1 class="f4 font-sans">
			<a href="/" aria-label="Home">
				<span>Johan</span><span aria-hidden="true" class="BackLink ml2">←</span>
			</a>
		</h1>

		<ul role="list" class="NavList">
          		<li>
         			<a href="/micro/">Micro</a>
          		</li>
          		<li>
         			<a href="/now/">Now</a>
          		</li>
          		<li>
         			<a href="/reading/">Reading</a>
          		</li>
          		<li>
         			<a href="/about/">About</a>
          		</li>
          		<li aria-current="page">
         			<a href="/writings/">Writings</a>
          		</li>
          		<li>
         			<a href="/recipes/">Recipes</a>
          		</li>
          		<li>
         			<a href="/feeds/">Feeds</a>
          		</li>
            <li>
     			<a href="/all">All pages</a>
      		</li>
        </ul>
	</div>
</nav>

	  </div>

      <script>
  // Only load on production environment.
  if (window.location.host !== new URL('https://johan.im').host) {
    window.goatcounter = {no_onload: true};
  }

  // Skip own views
  if (window.location.hash === '#skipgc')
    localStorage.setItem('skipgc', 't');
  if (localStorage.getItem('skipgc') === 't')
    window.goatcounter = {no_onload: true};
</script>
<script data-goatcounter="https://johanbrook.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>

  


</body></html>